{"version":3,"sources":["../src/readFile.ts"],"names":["readFile","name","options","callback","lock","parse","Promise","resolve","reject","err","read","fs","contents","parseJSON","JSON","then","content","result"],"mappings":";;;;;;;AAAA;;AAIA;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAT,CAAkBC,IAAlB,EAAgCC,OAAwB,GAAG,EAA3D,EAA+DC,QAAkB,GAAG,MAAY,CAAE,CAAlG,EAA0G;AACxG,MAAI,OAAOD,OAAP,KAAmB,UAAvB,EAAmC;AACjCC,IAAAA,QAAQ,GAAGD,OAAX;AACAA,IAAAA,OAAO,GAAG,EAAV;AACD;;AAEDA,EAAAA,OAAO,CAACE,IAAR,GAAeF,OAAO,CAACE,IAAR,IAAgB,KAA/B;AACAF,EAAAA,OAAO,CAACG,KAAR,GAAgBH,OAAO,CAACG,KAAR,IAAiB,KAAjC;;AAEA,QAAMD,IAAI,GAAG,UAASF,OAAT,EAA0E;AACrF,WAAO,IAAII,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAA2B;AAC5C,UAAI,CAACN,OAAO,CAACE,IAAb,EAAmB;AACjB,eAAOG,OAAO,CAAC,IAAD,CAAd;AACD;;AAED,8BAASN,IAAT,EAAe,UAASQ,GAAT,EAA4C;AACzD,YAAIA,GAAJ,EAAS;AACP,iBAAOD,MAAM,CAACC,GAAD,CAAb;AACD;;AACD,eAAOF,OAAO,CAAC,IAAD,CAAd;AACD,OALD;AAMD,KAXM,CAAP;AAYD,GAbD;;AAeA,QAAMG,IAAI,GAAG,YAAoD;AAC/D,WAAO,IAAIJ,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAA2B;AAC5CG,kBAAGX,QAAH,CAAYC,IAAZ,EAAkB,MAAlB,EAA0B,UAASQ,GAAT,EAAcG,QAAd,EAAwB;AAChD,YAAIH,GAAJ,EAAS;AACP,iBAAOD,MAAM,CAACC,GAAD,CAAb;AACD;;AAEDF,QAAAA,OAAO,CAACK,QAAD,CAAP;AACD,OAND;AAOD,KARM,CAAP;AASD,GAVD;;AAYA,QAAMC,SAAS,GAAG,UAASD,QAAT,EAA6C;AAC7D,WAAO,IAAIN,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAA2B;AAC5C,UAAI,CAACN,OAAO,CAACG,KAAb,EAAoB;AAClB,eAAOE,OAAO,CAACK,QAAD,CAAd;AACD;;AACD,UAAI;AACFA,QAAAA,QAAQ,GAAGE,IAAI,CAACT,KAAL,CAAWO,QAAX,CAAX;AACA,eAAOL,OAAO,CAACK,QAAD,CAAd;AACD,OAHD,CAGE,OAAOH,GAAP,EAAY;AACZ,eAAOD,MAAM,CAACC,GAAD,CAAb;AACD;AACF,KAVM,CAAP;AAWD,GAZD;;AAcAH,EAAAA,OAAO,CAACC,OAAR,GACGQ,IADH,CACQ,MAAMX,IAAI,CAACF,OAAD,CADlB,EAEGa,IAFH,CAEQ,MAAML,IAAI,EAFlB,EAGGK,IAHH,CAGQC,OAAO,IAAIH,SAAS,CAACG,OAAD,CAH5B,EAIGD,IAJH,CAKIE,MAAM,IAAId,QAAQ,CAAC,IAAD,EAAOc,MAAP,CALtB,EAMIR,GAAG,IAAIN,QAAQ,CAACM,GAAD,CANnB;AAQD","sourcesContent":["import fs from 'fs';\n\nimport { Callback } from '@verdaccio/types';\n\nimport { lockFile } from './lockfile';\n\nexport type ReadFileOptions = {\n  parse?: boolean;\n  lock?: boolean;\n};\n\n/**\n *  Reads a local file, which involves\n *  optionally taking a lock\n *  reading the file contents\n *  optionally parsing JSON contents\n * @param {*} name\n * @param {*} options\n * @param {*} callback\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction readFile(name: string, options: ReadFileOptions = {}, callback: Callback = (): void => {}): void {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options.lock = options.lock || false;\n  options.parse = options.parse || false;\n\n  const lock = function(options: ReadFileOptions): Promise<null | NodeJS.ErrnoException> {\n    return new Promise((resolve, reject): void => {\n      if (!options.lock) {\n        return resolve(null);\n      }\n\n      lockFile(name, function(err: NodeJS.ErrnoException | null) {\n        if (err) {\n          return reject(err);\n        }\n        return resolve(null);\n      });\n    });\n  };\n\n  const read = function(): Promise<NodeJS.ErrnoException | string> {\n    return new Promise((resolve, reject): void => {\n      fs.readFile(name, 'utf8', function(err, contents) {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(contents);\n      });\n    });\n  };\n\n  const parseJSON = function(contents: string): Promise<unknown> {\n    return new Promise((resolve, reject): void => {\n      if (!options.parse) {\n        return resolve(contents);\n      }\n      try {\n        contents = JSON.parse(contents);\n        return resolve(contents);\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  };\n\n  Promise.resolve()\n    .then(() => lock(options))\n    .then(() => read())\n    .then(content => parseJSON(content as string))\n    .then(\n      result => callback(null, result),\n      err => callback(err)\n    );\n}\n\nexport { readFile };\n"],"file":"readFile.js"}