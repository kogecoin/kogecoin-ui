"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addVersion = addVersion;
exports.default = publish;
exports.publishPackage = publishPackage;
exports.removeTarball = removeTarball;
exports.unPublishPackage = unPublishPackage;
exports.uploadPackageTarball = uploadPackageTarball;

var _debug = _interopRequireDefault(require("debug"));

var _lodash = _interopRequireDefault(require("lodash"));

var _mime = _interopRequireDefault(require("mime"));

var _path = _interopRequireDefault(require("path"));

var _constants = require("../../../lib/constants");

var _logger = require("../../../lib/logger");

var _notify = require("../../../lib/notify");

var _storageUtils = require("../../../lib/storage-utils");

var _utils = require("../../../lib/utils");

var _middleware = require("../../middleware");

var _star = _interopRequireDefault(require("./star"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const debug = (0, _debug.default)('verdaccio:publish');

function publish(router, auth, storage, config) {
  const can = (0, _middleware.allow)(auth);
  /**
   * Publish a package / update package / un/start a package
   *
   * There are multiples scenarios here to be considered:
   *
   * 1. Publish scenario
   *
   * Publish a package consist of at least 1 step (PUT) with a metadata payload.
   * When a package is published, an _attachment property is present that contains the data
   * of the tarball.
   *
   * Example flow of publish.
   *
   *  npm http fetch PUT 201 http://localhost:4873/@scope%2ftest1 9627ms
      npm info lifecycle @scope/test1@1.0.1~publish: @scope/test1@1.0.1
      npm info lifecycle @scope/test1@1.0.1~postpublish: @scope/test1@1.0.1
      + @scope/test1@1.0.1
      npm verb exit [ 0, true ]
   *
   *
   * 2. Unpublish scenario
   *
   * Unpublish consist in 3 steps.
   *  1. Try to fetch  metadata -> if it fails, return 404
   *  2. Compute metadata locally (client side) and send a mutate payload excluding the version to be unpublished
   *    eg: if metadata reflects 1.0.1, 1.0.2 and 1.0.3, the computed metadata won't include 1.0.3.
   *  3. Once the second step has been successfully finished, delete the tarball.
   *
   *  All these steps are consecutive and required, there is no transacions here, if step 3 fails, metadata might
   *  get corrupted.
   *
   *  Note the unpublish call will suffix in the url a /-rev/14-5d500cfce92f90fd revision number, this not
   *  used internally.
   *
   *
   * Example flow of unpublish.
   *
   * npm http fetch GET 200 http://localhost:4873/@scope%2ftest1?write=true 1680ms
     npm http fetch PUT 201 http://localhost:4873/@scope%2ftest1/-rev/14-5d500cfce92f90fd 956606ms attempt #2
     npm http fetch GET 200 http://localhost:4873/@scope%2ftest1?write=true 1601ms
     npm http fetch DELETE 201 http://localhost:4873/@scope%2ftest1/-/test1-1.0.3.tgz/-rev/16-e11c8db282b2d992 19ms
   *
   * 3. Star a package
   *
   * Permissions: start a package depends of the publish and unpublish permissions, there is no specific flag for star or un start.
   * The URL for star is similar to the unpublish (change package format)
   *
   * npm has no enpoint for star a package, rather mutate the metadata and acts as, the difference is the
   * users property which is part of the payload and the body only includes
   *
   * {
    "_id": pkgName,
   	"_rev": "3-b0cdaefc9bdb77c8",
    "users": {
      [username]: boolean value (true, false)
    }
  }
   *
   */

  router.put('/:package/:_rev?/:revision?', can('publish'), (0, _middleware.media)(_mime.default.getType('json')), _middleware.expectJson, publishPackage(storage, config, auth));
  /**
   * Un-publishing an entire package.
   *
   * This scenario happens when the first call detect there is only one version remaining
   * in the metadata, then the client decides to DELETE the resource
   * npm http fetch GET 304 http://localhost:4873/@scope%2ftest1?write=true 1076ms (from cache)
     npm http fetch DELETE 201 http://localhost:4873/@scope%2ftest1/-rev/18-d8ebe3020bd4ac9c 22ms
   */

  router.delete('/:package/-rev/*', can('unpublish'), unPublishPackage(storage)); // removing a tarball

  router.delete('/:package/-/:filename/-rev/:revision', can('unpublish'), can('publish'), removeTarball(storage)); // uploading package tarball

  router.put('/:package/-/:filename/*', can('publish'), (0, _middleware.media)(_constants.HEADERS.OCTET_STREAM), uploadPackageTarball(storage)); // adding a version

  router.put('/:package/:version/-tag/:tag', can('publish'), (0, _middleware.media)(_mime.default.getType('json')), _middleware.expectJson, addVersion(storage));
}
/**
 * Publish a package
 */


function publishPackage(storage, config, auth) {
  const starApi = (0, _star.default)(storage);
  return function (req, res, next) {
    const packageName = req.params.package;
    debug('publishing or updating a new version for %o', packageName);
    /**
     * Write tarball of stream data from package clients.
     */

    const createTarball = function (filename, data, cb) {
      const stream = storage.addTarball(packageName, filename);
      stream.on('error', function (err) {
        cb(err);
      });
      stream.on('success', function () {
        cb();
      }); // this is dumb and memory-consuming, but what choices do we have?
      // flow: we need first refactor this file before decides which type use here

      stream.end(Buffer.from(data.data, 'base64'));
      stream.done();
    };
    /**
     * Add new package version in storage
     */


    const createVersion = function (version, metadata, cb) {
      storage.addVersion(packageName, version, metadata, null, cb);
    };
    /**
     * Add new tags in storage
     */


    const addTags = function (tags, cb) {
      storage.mergeTags(packageName, tags, cb);
    };

    const afterChange = function (error, okMessage, metadata) {
      const metadataCopy = _objectSpread({}, metadata);

      const {
        _attachments,
        versions
      } = metadataCopy; // `npm star` wouldn't have attachments
      // and `npm deprecate` would have attachments as a empty object, i.e {}

      if (_lodash.default.isNil(_attachments) || JSON.stringify(_attachments) === '{}') {
        if (error) {
          return next(error);
        }

        res.status(_constants.HTTP_STATUS.CREATED);
        return next({
          ok: okMessage,
          success: true
        });
      } // npm-registry-client 0.3+ embeds tarball into the json upload
      // https://github.com/isaacs/npm-registry-client/commit/e9fbeb8b67f249394f735c74ef11fe4720d46ca0
      // issue https://github.com/rlidwka/sinopia/issues/31, dealing with it here:


      const isInvalidBodyFormat = (0, _utils.isObject)(_attachments) === false || (0, _utils.hasDiffOneKey)(_attachments) || (0, _utils.isObject)(versions) === false || (0, _utils.hasDiffOneKey)(versions);

      if (isInvalidBodyFormat) {
        // npm is doing something strange again
        // if this happens in normal circumstances, report it as a bug
        _logger.logger.info({
          packageName
        }, `wrong package format on publish a package @{packageName}`);

        return next(_utils.ErrorCode.getBadRequest(_constants.API_ERROR.UNSUPORTED_REGISTRY_CALL));
      }

      if (error && error.status !== _constants.HTTP_STATUS.CONFLICT) {
        return next(error);
      } // at this point document is either created or existed before


      const [firstAttachmentKey] = Object.keys(_attachments);
      createTarball(_path.default.basename(firstAttachmentKey), _attachments[firstAttachmentKey], function (error) {
        if (error) {
          return next(error);
        }

        const versionToPublish = Object.keys(versions)[0];
        const versionMetadataToPublish = versions[versionToPublish];
        versionMetadataToPublish.readme = _lodash.default.isNil(versionMetadataToPublish.readme) === false ? String(versionMetadataToPublish.readme) : '';
        createVersion(versionToPublish, versionMetadataToPublish, function (error) {
          if (error) {
            return next(error);
          }

          addTags(metadataCopy[_constants.DIST_TAGS], async function (error) {
            if (error) {
              return next(error);
            }

            try {
              await (0, _notify.notify)(metadataCopy, config, req.remote_user, `${metadataCopy.name}@${versionToPublish}`);
            } catch (error) {
              _logger.logger.error({
                error
              }, 'notify batch service has failed: @{error}');
            }

            res.status(_constants.HTTP_STATUS.CREATED);
            return next({
              ok: okMessage,
              success: true
            });
          });
        });
      });
    };

    if ((0, _storageUtils.isPublishablePackage)(req.body) === false && (0, _utils.isObject)(req.body.users)) {
      return starApi(req, res, next);
    }

    try {
      const metadata = (0, _utils.validateMetadata)(req.body, packageName); // check _attachments to distinguish publish and deprecate

      if (req.params._rev || (0, _utils.isRelatedToDeprecation)(req.body) && _lodash.default.isEmpty(req.body._attachments)) {
        debug('updating a new version for %o', packageName); // we check unpublish permissions, an update is basically remove versions

        const remote = req.remote_user;
        auth.allow_unpublish({
          packageName
        }, remote, error => {
          if (error) {
            _logger.logger.error({
              packageName
            }, `not allowed to unpublish a version for @{packageName}`);

            return next(error);
          }

          storage.changePackage(packageName, metadata, req.params.revision, function (error) {
            afterChange(error, _constants.API_MESSAGE.PKG_CHANGED, metadata);
          });
        });
      } else {
        debug('adding a new version for %o', packageName);
        storage.addPackage(packageName, metadata, function (error) {
          afterChange(error, _constants.API_MESSAGE.PKG_CREATED, metadata);
        });
      }
    } catch (error) {
      _logger.logger.error({
        packageName
      }, 'error on publish, bad package data for @{packageName}');

      return next(_utils.ErrorCode.getBadData(_constants.API_ERROR.BAD_PACKAGE_DATA));
    }
  };
}
/**
 * un-publish a package
 */


function unPublishPackage(storage) {
  return function (req, res, next) {
    const packageName = req.params.package;
    debug('unpublishing %o', packageName);
    storage.removePackage(packageName, function (err) {
      if (err) {
        return next(err);
      }

      res.status(_constants.HTTP_STATUS.CREATED);
      return next({
        ok: _constants.API_MESSAGE.PKG_REMOVED
      });
    });
  };
}
/**
 * Delete tarball
 */


function removeTarball(storage) {
  return function (req, res, next) {
    const packageName = req.params.package;
    const {
      filename,
      revision
    } = req.params;
    debug('removing a tarball for %o-%o-%o', packageName, filename, revision);
    storage.removeTarball(packageName, filename, revision, function (err) {
      if (err) {
        return next(err);
      }

      res.status(_constants.HTTP_STATUS.CREATED);
      debug('success remove tarball for %o-%o-%o', packageName, filename, revision);
      return next({
        ok: _constants.API_MESSAGE.TARBALL_REMOVED
      });
    });
  };
}
/**
 * Adds a new version
 */


function addVersion(storage) {
  return function (req, res, next) {
    const {
      version,
      tag
    } = req.params;
    const packageName = req.params.package;
    storage.addVersion(packageName, version, req.body, tag, function (error) {
      if (error) {
        return next(error);
      }

      res.status(_constants.HTTP_STATUS.CREATED);
      return next({
        ok: _constants.API_MESSAGE.PKG_PUBLISHED
      });
    });
  };
}
/**
 * uploadPackageTarball
 */


function uploadPackageTarball(storage) {
  return function (req, res, next) {
    const packageName = req.params.package;
    const stream = storage.addTarball(packageName, req.params.filename);
    req.pipe(stream); // checking if end event came before closing

    let complete = false;
    req.on('end', function () {
      complete = true;
      stream.done();
    });
    req.on('close', function () {
      if (!complete) {
        stream.abort();
      }
    });
    stream.on('error', function (err) {
      return res.locals.report_error(err);
    });
    stream.on('success', function () {
      res.status(_constants.HTTP_STATUS.CREATED);
      return next({
        ok: _constants.API_MESSAGE.TARBALL_UPLOADED
      });
    });
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hcGkvZW5kcG9pbnQvYXBpL3B1Ymxpc2gudHMiXSwibmFtZXMiOlsiZGVidWciLCJwdWJsaXNoIiwicm91dGVyIiwiYXV0aCIsInN0b3JhZ2UiLCJjb25maWciLCJjYW4iLCJwdXQiLCJtaW1lIiwiZ2V0VHlwZSIsImV4cGVjdEpzb24iLCJwdWJsaXNoUGFja2FnZSIsImRlbGV0ZSIsInVuUHVibGlzaFBhY2thZ2UiLCJyZW1vdmVUYXJiYWxsIiwiSEVBREVSUyIsIk9DVEVUX1NUUkVBTSIsInVwbG9hZFBhY2thZ2VUYXJiYWxsIiwiYWRkVmVyc2lvbiIsInN0YXJBcGkiLCJyZXEiLCJyZXMiLCJuZXh0IiwicGFja2FnZU5hbWUiLCJwYXJhbXMiLCJwYWNrYWdlIiwiY3JlYXRlVGFyYmFsbCIsImZpbGVuYW1lIiwiZGF0YSIsImNiIiwic3RyZWFtIiwiYWRkVGFyYmFsbCIsIm9uIiwiZXJyIiwiZW5kIiwiQnVmZmVyIiwiZnJvbSIsImRvbmUiLCJjcmVhdGVWZXJzaW9uIiwidmVyc2lvbiIsIm1ldGFkYXRhIiwiYWRkVGFncyIsInRhZ3MiLCJtZXJnZVRhZ3MiLCJhZnRlckNoYW5nZSIsImVycm9yIiwib2tNZXNzYWdlIiwibWV0YWRhdGFDb3B5IiwiX2F0dGFjaG1lbnRzIiwidmVyc2lvbnMiLCJfIiwiaXNOaWwiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhdHVzIiwiSFRUUF9TVEFUVVMiLCJDUkVBVEVEIiwib2siLCJzdWNjZXNzIiwiaXNJbnZhbGlkQm9keUZvcm1hdCIsImxvZ2dlciIsImluZm8iLCJFcnJvckNvZGUiLCJnZXRCYWRSZXF1ZXN0IiwiQVBJX0VSUk9SIiwiVU5TVVBPUlRFRF9SRUdJU1RSWV9DQUxMIiwiQ09ORkxJQ1QiLCJmaXJzdEF0dGFjaG1lbnRLZXkiLCJPYmplY3QiLCJrZXlzIiwiUGF0aCIsImJhc2VuYW1lIiwidmVyc2lvblRvUHVibGlzaCIsInZlcnNpb25NZXRhZGF0YVRvUHVibGlzaCIsInJlYWRtZSIsIlN0cmluZyIsIkRJU1RfVEFHUyIsInJlbW90ZV91c2VyIiwibmFtZSIsImJvZHkiLCJ1c2VycyIsIl9yZXYiLCJpc0VtcHR5IiwicmVtb3RlIiwiYWxsb3dfdW5wdWJsaXNoIiwiY2hhbmdlUGFja2FnZSIsInJldmlzaW9uIiwiQVBJX01FU1NBR0UiLCJQS0dfQ0hBTkdFRCIsImFkZFBhY2thZ2UiLCJQS0dfQ1JFQVRFRCIsImdldEJhZERhdGEiLCJCQURfUEFDS0FHRV9EQVRBIiwicmVtb3ZlUGFja2FnZSIsIlBLR19SRU1PVkVEIiwiVEFSQkFMTF9SRU1PVkVEIiwidGFnIiwiUEtHX1BVQkxJU0hFRCIsInBpcGUiLCJjb21wbGV0ZSIsImFib3J0IiwibG9jYWxzIiwicmVwb3J0X2Vycm9yIiwiVEFSQkFMTF9VUExPQURFRCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxNQUFNQSxLQUFLLEdBQUcsb0JBQVcsbUJBQVgsQ0FBZDs7QUFFZSxTQUFTQyxPQUFULENBQWlCQyxNQUFqQixFQUFpQ0MsSUFBakMsRUFBOENDLE9BQTlDLEVBQXdFQyxNQUF4RSxFQUE4RjtBQUMzRyxRQUFNQyxHQUFHLEdBQUcsdUJBQU1ILElBQU4sQ0FBWjtBQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QU8sQ0FBQzJCLFVBQVIsQ0FBbUJSLFdBQW5CLEVBQWdDSCxHQUFHLENBQUNJLE1BQUosQ0FBV0csUUFBM0MsQ0FBZjtBQUNBUCxJQUFBQSxHQUFHLENBQUM4RSxJQUFKLENBQVNwRSxNQUFULEVBSHdGLENBS3hGOztBQUNBLFFBQUlxRSxRQUFRLEdBQUcsS0FBZjtBQUNBL0UsSUFBQUEsR0FBRyxDQUFDWSxFQUFKLENBQU8sS0FBUCxFQUFjLFlBQVk7QUFDeEJtRSxNQUFBQSxRQUFRLEdBQUcsSUFBWDtBQUNBckUsTUFBQUEsTUFBTSxDQUFDTyxJQUFQO0FBQ0QsS0FIRDtBQUtBakIsSUFBQUEsR0FBRyxDQUFDWSxFQUFKLENBQU8sT0FBUCxFQUFnQixZQUFZO0FBQzFCLFVBQUksQ0FBQ21FLFFBQUwsRUFBZTtBQUNickUsUUFBQUEsTUFBTSxDQUFDc0UsS0FBUDtBQUNEO0FBQ0YsS0FKRDtBQU1BdEUsSUFBQUEsTUFBTSxDQUFDRSxFQUFQLENBQVUsT0FBVixFQUFtQixVQUFVQyxHQUFWLEVBQWU7QUFDaEMsYUFBT1osR0FBRyxDQUFDZ0YsTUFBSixDQUFXQyxZQUFYLENBQXdCckUsR0FBeEIsQ0FBUDtBQUNELEtBRkQ7QUFJQUgsSUFBQUEsTUFBTSxDQUFDRSxFQUFQLENBQVUsU0FBVixFQUFxQixZQUFZO0FBQy9CWCxNQUFBQSxHQUFHLENBQUNpQyxNQUFKLENBQVdDLHVCQUFZQyxPQUF2QjtBQUNBLGFBQU9sQyxJQUFJLENBQUM7QUFDVm1DLFFBQUFBLEVBQUUsRUFBRThCLHVCQUFZZ0I7QUFETixPQUFELENBQVg7QUFHRCxLQUxEO0FBTUQsR0E1QkQ7QUE2QkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYnVpbGREZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdleHByZXNzJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbWltZSBmcm9tICdtaW1lJztcbmltcG9ydCBQYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBDYWxsYmFjaywgQ29uZmlnLCBNZXJnZVRhZ3MsIFBhY2thZ2UsIFZlcnNpb24gfSBmcm9tICdAdmVyZGFjY2lvL3R5cGVzJztcblxuaW1wb3J0IHsgJE5leHRGdW5jdGlvblZlciwgJFJlcXVlc3RFeHRlbmQsICRSZXNwb25zZUV4dGVuZCwgSUF1dGgsIElTdG9yYWdlSGFuZGxlciB9IGZyb20gJy4uLy4uLy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IEFQSV9FUlJPUiwgQVBJX01FU1NBR0UsIERJU1RfVEFHUywgSEVBREVSUywgSFRUUF9TVEFUVVMgfSBmcm9tICcuLi8uLi8uLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uLy4uL2xpYi9sb2dnZXInO1xuaW1wb3J0IHsgbm90aWZ5IH0gZnJvbSAnLi4vLi4vLi4vbGliL25vdGlmeSc7XG5pbXBvcnQgeyBpc1B1Ymxpc2hhYmxlUGFja2FnZSB9IGZyb20gJy4uLy4uLy4uL2xpYi9zdG9yYWdlLXV0aWxzJztcbmltcG9ydCB7IEVycm9yQ29kZSwgaGFzRGlmZk9uZUtleSwgaXNPYmplY3QsIGlzUmVsYXRlZFRvRGVwcmVjYXRpb24sIHZhbGlkYXRlTWV0YWRhdGEgfSBmcm9tICcuLi8uLi8uLi9saWIvdXRpbHMnO1xuaW1wb3J0IHsgYWxsb3csIGV4cGVjdEpzb24sIG1lZGlhIH0gZnJvbSAnLi4vLi4vbWlkZGxld2FyZSc7XG5pbXBvcnQgc3RhciBmcm9tICcuL3N0YXInO1xuXG5jb25zdCBkZWJ1ZyA9IGJ1aWxkRGVidWcoJ3ZlcmRhY2NpbzpwdWJsaXNoJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHB1Ymxpc2gocm91dGVyOiBSb3V0ZXIsIGF1dGg6IElBdXRoLCBzdG9yYWdlOiBJU3RvcmFnZUhhbmRsZXIsIGNvbmZpZzogQ29uZmlnKTogdm9pZCB7XG4gIGNvbnN0IGNhbiA9IGFsbG93KGF1dGgpO1xuXG4gIC8qKlxuICAgKiBQdWJsaXNoIGEgcGFja2FnZSAvIHVwZGF0ZSBwYWNrYWdlIC8gdW4vc3RhcnQgYSBwYWNrYWdlXG4gICAqXG4gICAqIFRoZXJlIGFyZSBtdWx0aXBsZXMgc2NlbmFyaW9zIGhlcmUgdG8gYmUgY29uc2lkZXJlZDpcbiAgICpcbiAgICogMS4gUHVibGlzaCBzY2VuYXJpb1xuICAgKlxuICAgKiBQdWJsaXNoIGEgcGFja2FnZSBjb25zaXN0IG9mIGF0IGxlYXN0IDEgc3RlcCAoUFVUKSB3aXRoIGEgbWV0YWRhdGEgcGF5bG9hZC5cbiAgICogV2hlbiBhIHBhY2thZ2UgaXMgcHVibGlzaGVkLCBhbiBfYXR0YWNobWVudCBwcm9wZXJ0eSBpcyBwcmVzZW50IHRoYXQgY29udGFpbnMgdGhlIGRhdGFcbiAgICogb2YgdGhlIHRhcmJhbGwuXG4gICAqXG4gICAqIEV4YW1wbGUgZmxvdyBvZiBwdWJsaXNoLlxuICAgKlxuICAgKiAgbnBtIGh0dHAgZmV0Y2ggUFVUIDIwMSBodHRwOi8vbG9jYWxob3N0OjQ4NzMvQHNjb3BlJTJmdGVzdDEgOTYyN21zXG4gICAgICBucG0gaW5mbyBsaWZlY3ljbGUgQHNjb3BlL3Rlc3QxQDEuMC4xfnB1Ymxpc2g6IEBzY29wZS90ZXN0MUAxLjAuMVxuICAgICAgbnBtIGluZm8gbGlmZWN5Y2xlIEBzY29wZS90ZXN0MUAxLjAuMX5wb3N0cHVibGlzaDogQHNjb3BlL3Rlc3QxQDEuMC4xXG4gICAgICArIEBzY29wZS90ZXN0MUAxLjAuMVxuICAgICAgbnBtIHZlcmIgZXhpdCBbIDAsIHRydWUgXVxuICAgKlxuICAgKlxuICAgKiAyLiBVbnB1Ymxpc2ggc2NlbmFyaW9cbiAgICpcbiAgICogVW5wdWJsaXNoIGNvbnNpc3QgaW4gMyBzdGVwcy5cbiAgICogIDEuIFRyeSB0byBmZXRjaCAgbWV0YWRhdGEgLT4gaWYgaXQgZmFpbHMsIHJldHVybiA0MDRcbiAgICogIDIuIENvbXB1dGUgbWV0YWRhdGEgbG9jYWxseSAoY2xpZW50IHNpZGUpIGFuZCBzZW5kIGEgbXV0YXRlIHBheWxvYWQgZXhjbHVkaW5nIHRoZSB2ZXJzaW9uIHRvIGJlIHVucHVibGlzaGVkXG4gICAqICAgIGVnOiBpZiBtZXRhZGF0YSByZWZsZWN0cyAxLjAuMSwgMS4wLjIgYW5kIDEuMC4zLCB0aGUgY29tcHV0ZWQgbWV0YWRhdGEgd29uJ3QgaW5jbHVkZSAxLjAuMy5cbiAgICogIDMuIE9uY2UgdGhlIHNlY29uZCBzdGVwIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBmaW5pc2hlZCwgZGVsZXRlIHRoZSB0YXJiYWxsLlxuICAgKlxuICAgKiAgQWxsIHRoZXNlIHN0ZXBzIGFyZSBjb25zZWN1dGl2ZSBhbmQgcmVxdWlyZWQsIHRoZXJlIGlzIG5vIHRyYW5zYWNpb25zIGhlcmUsIGlmIHN0ZXAgMyBmYWlscywgbWV0YWRhdGEgbWlnaHRcbiAgICogIGdldCBjb3JydXB0ZWQuXG4gICAqXG4gICAqICBOb3RlIHRoZSB1bnB1Ymxpc2ggY2FsbCB3aWxsIHN1ZmZpeCBpbiB0aGUgdXJsIGEgLy1yZXYvMTQtNWQ1MDBjZmNlOTJmOTBmZCByZXZpc2lvbiBudW1iZXIsIHRoaXMgbm90XG4gICAqICB1c2VkIGludGVybmFsbHkuXG4gICAqXG4gICAqXG4gICAqIEV4YW1wbGUgZmxvdyBvZiB1bnB1Ymxpc2guXG4gICAqXG4gICAqIG5wbSBodHRwIGZldGNoIEdFVCAyMDAgaHR0cDovL2xvY2FsaG9zdDo0ODczL0BzY29wZSUyZnRlc3QxP3dyaXRlPXRydWUgMTY4MG1zXG4gICAgIG5wbSBodHRwIGZldGNoIFBVVCAyMDEgaHR0cDovL2xvY2FsaG9zdDo0ODczL0BzY29wZSUyZnRlc3QxLy1yZXYvMTQtNWQ1MDBjZmNlOTJmOTBmZCA5NTY2MDZtcyBhdHRlbXB0ICMyXG4gICAgIG5wbSBodHRwIGZldGNoIEdFVCAyMDAgaHR0cDovL2xvY2FsaG9zdDo0ODczL0BzY29wZSUyZnRlc3QxP3dyaXRlPXRydWUgMTYwMW1zXG4gICAgIG5wbSBodHRwIGZldGNoIERFTEVURSAyMDEgaHR0cDovL2xvY2FsaG9zdDo0ODczL0BzY29wZSUyZnRlc3QxLy0vdGVzdDEtMS4wLjMudGd6Ly1yZXYvMTYtZTExYzhkYjI4MmIyZDk5MiAxOW1zXG4gICAqXG4gICAqIDMuIFN0YXIgYSBwYWNrYWdlXG4gICAqXG4gICAqIFBlcm1pc3Npb25zOiBzdGFydCBhIHBhY2thZ2UgZGVwZW5kcyBvZiB0aGUgcHVibGlzaCBhbmQgdW5wdWJsaXNoIHBlcm1pc3Npb25zLCB0aGVyZSBpcyBubyBzcGVjaWZpYyBmbGFnIGZvciBzdGFyIG9yIHVuIHN0YXJ0LlxuICAgKiBUaGUgVVJMIGZvciBzdGFyIGlzIHNpbWlsYXIgdG8gdGhlIHVucHVibGlzaCAoY2hhbmdlIHBhY2thZ2UgZm9ybWF0KVxuICAgKlxuICAgKiBucG0gaGFzIG5vIGVucG9pbnQgZm9yIHN0YXIgYSBwYWNrYWdlLCByYXRoZXIgbXV0YXRlIHRoZSBtZXRhZGF0YSBhbmQgYWN0cyBhcywgdGhlIGRpZmZlcmVuY2UgaXMgdGhlXG4gICAqIHVzZXJzIHByb3BlcnR5IHdoaWNoIGlzIHBhcnQgb2YgdGhlIHBheWxvYWQgYW5kIHRoZSBib2R5IG9ubHkgaW5jbHVkZXNcbiAgICpcbiAgICoge1xuXHRcdCAgXCJfaWRcIjogcGtnTmFtZSxcblx0ICBcdFwiX3JldlwiOiBcIjMtYjBjZGFlZmM5YmRiNzdjOFwiLFxuXHRcdCAgXCJ1c2Vyc1wiOiB7XG5cdFx0ICAgIFt1c2VybmFtZV06IGJvb2xlYW4gdmFsdWUgKHRydWUsIGZhbHNlKVxuXHRcdCAgfVxuXHR9XG4gICAqXG4gICAqL1xuICByb3V0ZXIucHV0KCcvOnBhY2thZ2UvOl9yZXY/LzpyZXZpc2lvbj8nLCBjYW4oJ3B1Ymxpc2gnKSwgbWVkaWEobWltZS5nZXRUeXBlKCdqc29uJykpLCBleHBlY3RKc29uLCBwdWJsaXNoUGFja2FnZShzdG9yYWdlLCBjb25maWcsIGF1dGgpKTtcblxuICAvKipcbiAgICogVW4tcHVibGlzaGluZyBhbiBlbnRpcmUgcGFja2FnZS5cbiAgICpcbiAgICogVGhpcyBzY2VuYXJpbyBoYXBwZW5zIHdoZW4gdGhlIGZpcnN0IGNhbGwgZGV0ZWN0IHRoZXJlIGlzIG9ubHkgb25lIHZlcnNpb24gcmVtYWluaW5nXG4gICAqIGluIHRoZSBtZXRhZGF0YSwgdGhlbiB0aGUgY2xpZW50IGRlY2lkZXMgdG8gREVMRVRFIHRoZSByZXNvdXJjZVxuICAgKiBucG0gaHR0cCBmZXRjaCBHRVQgMzA0IGh0dHA6Ly9sb2NhbGhvc3Q6NDg3My9Ac2NvcGUlMmZ0ZXN0MT93cml0ZT10cnVlIDEwNzZtcyAoZnJvbSBjYWNoZSlcbiAgICAgbnBtIGh0dHAgZmV0Y2ggREVMRVRFIDIwMSBodHRwOi8vbG9jYWxob3N0OjQ4NzMvQHNjb3BlJTJmdGVzdDEvLXJldi8xOC1kOGViZTMwMjBiZDRhYzljIDIybXNcbiAgICovXG4gIHJvdXRlci5kZWxldGUoJy86cGFja2FnZS8tcmV2LyonLCBjYW4oJ3VucHVibGlzaCcpLCB1blB1Ymxpc2hQYWNrYWdlKHN0b3JhZ2UpKTtcblxuICAvLyByZW1vdmluZyBhIHRhcmJhbGxcbiAgcm91dGVyLmRlbGV0ZSgnLzpwYWNrYWdlLy0vOmZpbGVuYW1lLy1yZXYvOnJldmlzaW9uJywgY2FuKCd1bnB1Ymxpc2gnKSwgY2FuKCdwdWJsaXNoJyksIHJlbW92ZVRhcmJhbGwoc3RvcmFnZSkpO1xuXG4gIC8vIHVwbG9hZGluZyBwYWNrYWdlIHRhcmJhbGxcbiAgcm91dGVyLnB1dCgnLzpwYWNrYWdlLy0vOmZpbGVuYW1lLyonLCBjYW4oJ3B1Ymxpc2gnKSwgbWVkaWEoSEVBREVSUy5PQ1RFVF9TVFJFQU0pLCB1cGxvYWRQYWNrYWdlVGFyYmFsbChzdG9yYWdlKSk7XG5cbiAgLy8gYWRkaW5nIGEgdmVyc2lvblxuICByb3V0ZXIucHV0KCcvOnBhY2thZ2UvOnZlcnNpb24vLXRhZy86dGFnJywgY2FuKCdwdWJsaXNoJyksIG1lZGlhKG1pbWUuZ2V0VHlwZSgnanNvbicpKSwgZXhwZWN0SnNvbiwgYWRkVmVyc2lvbihzdG9yYWdlKSk7XG59XG5cbi8qKlxuICogUHVibGlzaCBhIHBhY2thZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1Ymxpc2hQYWNrYWdlKHN0b3JhZ2U6IElTdG9yYWdlSGFuZGxlciwgY29uZmlnOiBDb25maWcsIGF1dGg6IElBdXRoKTogYW55IHtcbiAgY29uc3Qgc3RhckFwaSA9IHN0YXIoc3RvcmFnZSk7XG4gIHJldHVybiBmdW5jdGlvbiAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiAkUmVzcG9uc2VFeHRlbmQsIG5leHQ6ICROZXh0RnVuY3Rpb25WZXIpOiB2b2lkIHtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHJlcS5wYXJhbXMucGFja2FnZTtcbiAgICBkZWJ1ZygncHVibGlzaGluZyBvciB1cGRhdGluZyBhIG5ldyB2ZXJzaW9uIGZvciAlbycsIHBhY2thZ2VOYW1lKTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSB0YXJiYWxsIG9mIHN0cmVhbSBkYXRhIGZyb20gcGFja2FnZSBjbGllbnRzLlxuICAgICAqL1xuICAgIGNvbnN0IGNyZWF0ZVRhcmJhbGwgPSBmdW5jdGlvbiAoZmlsZW5hbWU6IHN0cmluZywgZGF0YSwgY2I6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBzdG9yYWdlLmFkZFRhcmJhbGwocGFja2FnZU5hbWUsIGZpbGVuYW1lKTtcbiAgICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5vbignc3VjY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH0pO1xuICAgICAgLy8gdGhpcyBpcyBkdW1iIGFuZCBtZW1vcnktY29uc3VtaW5nLCBidXQgd2hhdCBjaG9pY2VzIGRvIHdlIGhhdmU/XG4gICAgICAvLyBmbG93OiB3ZSBuZWVkIGZpcnN0IHJlZmFjdG9yIHRoaXMgZmlsZSBiZWZvcmUgZGVjaWRlcyB3aGljaCB0eXBlIHVzZSBoZXJlXG4gICAgICBzdHJlYW0uZW5kKEJ1ZmZlci5mcm9tKGRhdGEuZGF0YSwgJ2Jhc2U2NCcpKTtcbiAgICAgIHN0cmVhbS5kb25lKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBuZXcgcGFja2FnZSB2ZXJzaW9uIGluIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBjb25zdCBjcmVhdGVWZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb246IHN0cmluZywgbWV0YWRhdGE6IFZlcnNpb24sIGNiOiBDYWxsYmFjayk6IHZvaWQge1xuICAgICAgc3RvcmFnZS5hZGRWZXJzaW9uKHBhY2thZ2VOYW1lLCB2ZXJzaW9uLCBtZXRhZGF0YSwgbnVsbCwgY2IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbmV3IHRhZ3MgaW4gc3RvcmFnZVxuICAgICAqL1xuICAgIGNvbnN0IGFkZFRhZ3MgPSBmdW5jdGlvbiAodGFnczogTWVyZ2VUYWdzLCBjYjogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICAgIHN0b3JhZ2UubWVyZ2VUYWdzKHBhY2thZ2VOYW1lLCB0YWdzLCBjYik7XG4gICAgfTtcblxuICAgIGNvbnN0IGFmdGVyQ2hhbmdlID0gZnVuY3Rpb24gKGVycm9yLCBva01lc3NhZ2UsIG1ldGFkYXRhKTogdm9pZCB7XG4gICAgICBjb25zdCBtZXRhZGF0YUNvcHk6IFBhY2thZ2UgPSB7IC4uLm1ldGFkYXRhIH07XG5cbiAgICAgIGNvbnN0IHsgX2F0dGFjaG1lbnRzLCB2ZXJzaW9ucyB9ID0gbWV0YWRhdGFDb3B5O1xuXG4gICAgICAvLyBgbnBtIHN0YXJgIHdvdWxkbid0IGhhdmUgYXR0YWNobWVudHNcbiAgICAgIC8vIGFuZCBgbnBtIGRlcHJlY2F0ZWAgd291bGQgaGF2ZSBhdHRhY2htZW50cyBhcyBhIGVtcHR5IG9iamVjdCwgaS5lIHt9XG4gICAgICBpZiAoXy5pc05pbChfYXR0YWNobWVudHMpIHx8IEpTT04uc3RyaW5naWZ5KF9hdHRhY2htZW50cykgPT09ICd7fScpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5zdGF0dXMoSFRUUF9TVEFUVVMuQ1JFQVRFRCk7XG4gICAgICAgIHJldHVybiBuZXh0KHtcbiAgICAgICAgICBvazogb2tNZXNzYWdlLFxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBucG0tcmVnaXN0cnktY2xpZW50IDAuMysgZW1iZWRzIHRhcmJhbGwgaW50byB0aGUganNvbiB1cGxvYWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvbnBtLXJlZ2lzdHJ5LWNsaWVudC9jb21taXQvZTlmYmViOGI2N2YyNDkzOTRmNzM1Yzc0ZWYxMWZlNDcyMGQ0NmNhMFxuICAgICAgLy8gaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3JsaWR3a2Evc2lub3BpYS9pc3N1ZXMvMzEsIGRlYWxpbmcgd2l0aCBpdCBoZXJlOlxuICAgICAgY29uc3QgaXNJbnZhbGlkQm9keUZvcm1hdCA9IGlzT2JqZWN0KF9hdHRhY2htZW50cykgPT09IGZhbHNlIHx8IGhhc0RpZmZPbmVLZXkoX2F0dGFjaG1lbnRzKSB8fCBpc09iamVjdCh2ZXJzaW9ucykgPT09IGZhbHNlIHx8IGhhc0RpZmZPbmVLZXkodmVyc2lvbnMpO1xuXG4gICAgICBpZiAoaXNJbnZhbGlkQm9keUZvcm1hdCkge1xuICAgICAgICAvLyBucG0gaXMgZG9pbmcgc29tZXRoaW5nIHN0cmFuZ2UgYWdhaW5cbiAgICAgICAgLy8gaWYgdGhpcyBoYXBwZW5zIGluIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCByZXBvcnQgaXQgYXMgYSBidWdcbiAgICAgICAgbG9nZ2VyLmluZm8oeyBwYWNrYWdlTmFtZSB9LCBgd3JvbmcgcGFja2FnZSBmb3JtYXQgb24gcHVibGlzaCBhIHBhY2thZ2UgQHtwYWNrYWdlTmFtZX1gKTtcbiAgICAgICAgcmV0dXJuIG5leHQoRXJyb3JDb2RlLmdldEJhZFJlcXVlc3QoQVBJX0VSUk9SLlVOU1VQT1JURURfUkVHSVNUUllfQ0FMTCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IgJiYgZXJyb3Iuc3RhdHVzICE9PSBIVFRQX1NUQVRVUy5DT05GTElDVCkge1xuICAgICAgICByZXR1cm4gbmV4dChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0IHRoaXMgcG9pbnQgZG9jdW1lbnQgaXMgZWl0aGVyIGNyZWF0ZWQgb3IgZXhpc3RlZCBiZWZvcmVcbiAgICAgIGNvbnN0IFtmaXJzdEF0dGFjaG1lbnRLZXldID0gT2JqZWN0LmtleXMoX2F0dGFjaG1lbnRzKTtcblxuICAgICAgY3JlYXRlVGFyYmFsbChQYXRoLmJhc2VuYW1lKGZpcnN0QXR0YWNobWVudEtleSksIF9hdHRhY2htZW50c1tmaXJzdEF0dGFjaG1lbnRLZXldLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmVyc2lvblRvUHVibGlzaCA9IE9iamVjdC5rZXlzKHZlcnNpb25zKVswXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbk1ldGFkYXRhVG9QdWJsaXNoID0gdmVyc2lvbnNbdmVyc2lvblRvUHVibGlzaF07XG5cbiAgICAgICAgdmVyc2lvbk1ldGFkYXRhVG9QdWJsaXNoLnJlYWRtZSA9IF8uaXNOaWwodmVyc2lvbk1ldGFkYXRhVG9QdWJsaXNoLnJlYWRtZSkgPT09IGZhbHNlID8gU3RyaW5nKHZlcnNpb25NZXRhZGF0YVRvUHVibGlzaC5yZWFkbWUpIDogJyc7XG5cbiAgICAgICAgY3JlYXRlVmVyc2lvbih2ZXJzaW9uVG9QdWJsaXNoLCB2ZXJzaW9uTWV0YWRhdGFUb1B1Ymxpc2gsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZFRhZ3MobWV0YWRhdGFDb3B5W0RJU1RfVEFHU10sIGFzeW5jIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KGVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgbm90aWZ5KG1ldGFkYXRhQ29weSwgY29uZmlnLCByZXEucmVtb3RlX3VzZXIsIGAke21ldGFkYXRhQ29weS5uYW1lfUAke3ZlcnNpb25Ub1B1Ymxpc2h9YCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoeyBlcnJvciB9LCAnbm90aWZ5IGJhdGNoIHNlcnZpY2UgaGFzIGZhaWxlZDogQHtlcnJvcn0nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzLnN0YXR1cyhIVFRQX1NUQVRVUy5DUkVBVEVEKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KHsgb2s6IG9rTWVzc2FnZSwgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGlzUHVibGlzaGFibGVQYWNrYWdlKHJlcS5ib2R5KSA9PT0gZmFsc2UgJiYgaXNPYmplY3QocmVxLmJvZHkudXNlcnMpKSB7XG4gICAgICByZXR1cm4gc3RhckFwaShyZXEsIHJlcywgbmV4dCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gdmFsaWRhdGVNZXRhZGF0YShyZXEuYm9keSwgcGFja2FnZU5hbWUpO1xuICAgICAgLy8gY2hlY2sgX2F0dGFjaG1lbnRzIHRvIGRpc3Rpbmd1aXNoIHB1Ymxpc2ggYW5kIGRlcHJlY2F0ZVxuICAgICAgaWYgKHJlcS5wYXJhbXMuX3JldiB8fCAoaXNSZWxhdGVkVG9EZXByZWNhdGlvbihyZXEuYm9keSkgJiYgXy5pc0VtcHR5KHJlcS5ib2R5Ll9hdHRhY2htZW50cykpKSB7XG4gICAgICAgIGRlYnVnKCd1cGRhdGluZyBhIG5ldyB2ZXJzaW9uIGZvciAlbycsIHBhY2thZ2VOYW1lKTtcbiAgICAgICAgLy8gd2UgY2hlY2sgdW5wdWJsaXNoIHBlcm1pc3Npb25zLCBhbiB1cGRhdGUgaXMgYmFzaWNhbGx5IHJlbW92ZSB2ZXJzaW9uc1xuICAgICAgICBjb25zdCByZW1vdGUgPSByZXEucmVtb3RlX3VzZXI7XG4gICAgICAgIGF1dGguYWxsb3dfdW5wdWJsaXNoKHsgcGFja2FnZU5hbWUgfSwgcmVtb3RlLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcih7IHBhY2thZ2VOYW1lIH0sIGBub3QgYWxsb3dlZCB0byB1bnB1Ymxpc2ggYSB2ZXJzaW9uIGZvciBAe3BhY2thZ2VOYW1lfWApO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdG9yYWdlLmNoYW5nZVBhY2thZ2UocGFja2FnZU5hbWUsIG1ldGFkYXRhLCByZXEucGFyYW1zLnJldmlzaW9uLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFmdGVyQ2hhbmdlKGVycm9yLCBBUElfTUVTU0FHRS5QS0dfQ0hBTkdFRCwgbWV0YWRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdhZGRpbmcgYSBuZXcgdmVyc2lvbiBmb3IgJW8nLCBwYWNrYWdlTmFtZSk7XG4gICAgICAgIHN0b3JhZ2UuYWRkUGFja2FnZShwYWNrYWdlTmFtZSwgbWV0YWRhdGEsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGFmdGVyQ2hhbmdlKGVycm9yLCBBUElfTUVTU0FHRS5QS0dfQ1JFQVRFRCwgbWV0YWRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKHsgcGFja2FnZU5hbWUgfSwgJ2Vycm9yIG9uIHB1Ymxpc2gsIGJhZCBwYWNrYWdlIGRhdGEgZm9yIEB7cGFja2FnZU5hbWV9Jyk7XG4gICAgICByZXR1cm4gbmV4dChFcnJvckNvZGUuZ2V0QmFkRGF0YShBUElfRVJST1IuQkFEX1BBQ0tBR0VfREFUQSkpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiB1bi1wdWJsaXNoIGEgcGFja2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5QdWJsaXNoUGFja2FnZShzdG9yYWdlOiBJU3RvcmFnZUhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXE6ICRSZXF1ZXN0RXh0ZW5kLCByZXM6ICRSZXNwb25zZUV4dGVuZCwgbmV4dDogJE5leHRGdW5jdGlvblZlcik6IHZvaWQge1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcmVxLnBhcmFtcy5wYWNrYWdlO1xuICAgIGRlYnVnKCd1bnB1Ymxpc2hpbmcgJW8nLCBwYWNrYWdlTmFtZSk7XG4gICAgc3RvcmFnZS5yZW1vdmVQYWNrYWdlKHBhY2thZ2VOYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICB9XG4gICAgICByZXMuc3RhdHVzKEhUVFBfU1RBVFVTLkNSRUFURUQpO1xuICAgICAgcmV0dXJuIG5leHQoeyBvazogQVBJX01FU1NBR0UuUEtHX1JFTU9WRUQgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogRGVsZXRlIHRhcmJhbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRhcmJhbGwoc3RvcmFnZTogSVN0b3JhZ2VIYW5kbGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVxOiAkUmVxdWVzdEV4dGVuZCwgcmVzOiAkUmVzcG9uc2VFeHRlbmQsIG5leHQ6ICROZXh0RnVuY3Rpb25WZXIpOiB2b2lkIHtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHJlcS5wYXJhbXMucGFja2FnZTtcbiAgICBjb25zdCB7IGZpbGVuYW1lLCByZXZpc2lvbiB9ID0gcmVxLnBhcmFtcztcbiAgICBkZWJ1ZygncmVtb3ZpbmcgYSB0YXJiYWxsIGZvciAlby0lby0lbycsIHBhY2thZ2VOYW1lLCBmaWxlbmFtZSwgcmV2aXNpb24pO1xuICAgIHN0b3JhZ2UucmVtb3ZlVGFyYmFsbChwYWNrYWdlTmFtZSwgZmlsZW5hbWUsIHJldmlzaW9uLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICB9XG4gICAgICByZXMuc3RhdHVzKEhUVFBfU1RBVFVTLkNSRUFURUQpO1xuICAgICAgZGVidWcoJ3N1Y2Nlc3MgcmVtb3ZlIHRhcmJhbGwgZm9yICVvLSVvLSVvJywgcGFja2FnZU5hbWUsIGZpbGVuYW1lLCByZXZpc2lvbik7XG4gICAgICByZXR1cm4gbmV4dCh7IG9rOiBBUElfTUVTU0FHRS5UQVJCQUxMX1JFTU9WRUQgfSk7XG4gICAgfSk7XG4gIH07XG59XG4vKipcbiAqIEFkZHMgYSBuZXcgdmVyc2lvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkVmVyc2lvbihzdG9yYWdlOiBJU3RvcmFnZUhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXE6ICRSZXF1ZXN0RXh0ZW5kLCByZXM6ICRSZXNwb25zZUV4dGVuZCwgbmV4dDogJE5leHRGdW5jdGlvblZlcik6IHZvaWQge1xuICAgIGNvbnN0IHsgdmVyc2lvbiwgdGFnIH0gPSByZXEucGFyYW1zO1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcmVxLnBhcmFtcy5wYWNrYWdlO1xuXG4gICAgc3RvcmFnZS5hZGRWZXJzaW9uKHBhY2thZ2VOYW1lLCB2ZXJzaW9uLCByZXEuYm9keSwgdGFnLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbmV4dChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlcy5zdGF0dXMoSFRUUF9TVEFUVVMuQ1JFQVRFRCk7XG4gICAgICByZXR1cm4gbmV4dCh7XG4gICAgICAgIG9rOiBBUElfTUVTU0FHRS5QS0dfUFVCTElTSEVELFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogdXBsb2FkUGFja2FnZVRhcmJhbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwbG9hZFBhY2thZ2VUYXJiYWxsKHN0b3JhZ2U6IElTdG9yYWdlSGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlcTogJFJlcXVlc3RFeHRlbmQsIHJlczogJFJlc3BvbnNlRXh0ZW5kLCBuZXh0OiAkTmV4dEZ1bmN0aW9uVmVyKTogdm9pZCB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSByZXEucGFyYW1zLnBhY2thZ2U7XG4gICAgY29uc3Qgc3RyZWFtID0gc3RvcmFnZS5hZGRUYXJiYWxsKHBhY2thZ2VOYW1lLCByZXEucGFyYW1zLmZpbGVuYW1lKTtcbiAgICByZXEucGlwZShzdHJlYW0pO1xuXG4gICAgLy8gY2hlY2tpbmcgaWYgZW5kIGV2ZW50IGNhbWUgYmVmb3JlIGNsb3NpbmdcbiAgICBsZXQgY29tcGxldGUgPSBmYWxzZTtcbiAgICByZXEub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5kb25lKCk7XG4gICAgfSk7XG5cbiAgICByZXEub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjb21wbGV0ZSkge1xuICAgICAgICBzdHJlYW0uYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gcmVzLmxvY2Fscy5yZXBvcnRfZXJyb3IoZXJyKTtcbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbignc3VjY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcy5zdGF0dXMoSFRUUF9TVEFUVVMuQ1JFQVRFRCk7XG4gICAgICByZXR1cm4gbmV4dCh7XG4gICAgICAgIG9rOiBBUElfTUVTU0FHRS5UQVJCQUxMX1VQTE9BREVELFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG4iXX0=