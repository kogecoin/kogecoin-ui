"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _JSONStream = _interopRequireDefault(require("JSONStream"));

var _debug = _interopRequireDefault(require("debug"));

var _lodash = _interopRequireDefault(require("lodash"));

var _request = _interopRequireDefault(require("request"));

var _stream = _interopRequireDefault(require("stream"));

var _url = _interopRequireDefault(require("url"));

var _zlib = _interopRequireDefault(require("zlib"));

var _streams = require("@verdaccio/streams");

var _constants = require("./constants");

var _logger = require("./logger");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug.default)('verdaccio:up-storage');

const encode = function (thing) {
  return encodeURIComponent(thing).replace(/^%40/, '@');
};

const jsonContentType = _constants.HEADERS.JSON;
const contentTypeAccept = `${jsonContentType};`;
/**
 * Just a helper (`config[key] || default` doesn't work because of zeroes)
 */

const setConfig = (config, key, def) => {
  return _lodash.default.isNil(config[key]) === false ? config[key] : def;
};
/**
 * Implements Storage interface
 * (same for storage.js, local-storage.js, up-storage.js)
 */


class ProxyStorage {
  // FIXME: upname is assigned to each instance
  // @ts-ignore
  // FIXME: proxy can be boolean or object, something smells here
  // @ts-ignore
  // @ts-ignore

  /**
   * Constructor
   * @param {*} config
   * @param {*} mainConfig
   */
  constructor(config, mainConfig) {
    this.config = config;
    this.failed_requests = 0; // @ts-ignore

    this.userAgent = mainConfig.user_agent;
    this.ca = config.ca;
    this.logger = _logger.logger;
    this.server_id = mainConfig.server_id;
    this.url = _url.default.parse(this.config.url); // $FlowFixMe

    this._setupProxy(this.url.hostname, config, mainConfig, this.url.protocol === 'https:');

    this.config.url = this.config.url.replace(/\/$/, '');

    if (this.config.timeout && Number(this.config.timeout) >= 1000) {
      this.logger.warn(['Too big timeout value: ' + this.config.timeout, 'We changed time format to nginx-like one', '(see http://nginx.org/en/docs/syntax.html)', 'so please update your config accordingly'].join('\n'));
    } // a bunch of different configurable timers


    this.maxage = (0, _utils.parseInterval)(setConfig(this.config, 'maxage', '2m'));
    this.timeout = (0, _utils.parseInterval)(setConfig(this.config, 'timeout', '30s'));
    this.max_fails = Number(setConfig(this.config, 'max_fails', 2));
    this.fail_timeout = (0, _utils.parseInterval)(setConfig(this.config, 'fail_timeout', '5m'));
    this.strict_ssl = Boolean(setConfig(this.config, 'strict_ssl', true));
    this.agent_options = setConfig(this.config, 'agent_options', {
      keepAlive: true,
      maxSockets: 40,
      maxFreeSockets: 10
    });
  }
  /**
   * Fetch an asset.
   * @param {*} options
   * @param {*} cb
   * @return {Request}
   */


  request(options, cb) {
    let json;

    if (this._statusCheck() === false) {
      const streamRead = new _stream.default.Readable();
      process.nextTick(function () {
        if (cb) {
          cb(_utils.ErrorCode.getInternalError(_constants.API_ERROR.UPLINK_OFFLINE));
        }

        streamRead.emit('error', _utils.ErrorCode.getInternalError(_constants.API_ERROR.UPLINK_OFFLINE));
      }); // $FlowFixMe

      streamRead._read = function () {}; // preventing 'Uncaught, unspecified "error" event'


      streamRead.on('error', function () {});
      return streamRead;
    }

    const self = this;

    const headers = this._setHeaders(options);

    this._addProxyHeaders(options.req, headers);

    this._overrideWithUpLinkConfLocaligHeaders(headers);

    const method = options.method || 'GET';
    const uri = options.uri_full || this.config.url + options.uri;
    self.logger.info({
      method: method,
      headers: headers,
      uri: uri
    }, "making request: '@{method} @{uri}'");

    if ((0, _utils.isObject)(options.json)) {
      json = JSON.stringify(options.json);
      headers['Content-Type'] = headers['Content-Type'] || _constants.HEADERS.JSON;
    }

    const requestCallback = cb ? function (err, res, body) {
      let error;
      const responseLength = err ? 0 : body.length; // $FlowFixMe

      processBody();
      logActivity(); // $FlowFixMe

      cb(err, res, body);
      /**
       * Perform a decode.
       */

      function processBody() {
        if (err) {
          error = err.message;
          return;
        }

        if (options.json && res.statusCode < 300) {
          try {
            // $FlowFixMe
            body = JSON.parse(body.toString(_constants.CHARACTER_ENCODING.UTF8));
          } catch (_err) {
            body = {};
            err = _err;
            error = err.message;
          }
        }

        if (!err && (0, _utils.isObject)(body)) {
          if (_lodash.default.isString(body.error)) {
            error = body.error;
          }
        }
      }
      /**
       * Perform a log.
       */


      function logActivity() {
        let message = "@{!status}, req: '@{request.method} @{request.url}'";
        message += error ? ', error: @{!error}' : ', bytes: @{bytes.in}/@{bytes.out}';
        self.logger.http({
          err: err || undefined,
          // if error is null/false change this to undefined so it wont log
          request: {
            method: method,
            url: uri
          },
          status: res != null ? res.statusCode : 'ERR',
          error: error,
          bytes: {
            in: json ? json.length : 0,
            out: responseLength || 0
          }
        }, message);
      }
    } : undefined;
    let requestOptions = {
      url: uri,
      method: method,
      headers: headers,
      body: json,
      proxy: this.proxy,
      encoding: null,
      gzip: true,
      timeout: this.timeout,
      strictSSL: this.strict_ssl,
      agentOptions: this.agent_options
    };

    if (this.ca) {
      requestOptions = Object.assign({}, requestOptions, {
        ca: this.ca
      });
    }

    const req = (0, _request.default)(requestOptions, requestCallback);
    let statusCalled = false;
    req.on('response', function (res) {
      // FIXME: _verdaccio_aborted seems not used
      // @ts-ignore
      if (!req._verdaccio_aborted && !statusCalled) {
        statusCalled = true;

        self._statusCheck(true);
      }

      if (_lodash.default.isNil(requestCallback) === false) {
        (function do_log() {
          const message = "@{!status}, req: '@{request.method} @{request.url}' (streaming)";
          self.logger.http({
            request: {
              method: method,
              url: uri
            },
            status: _lodash.default.isNull(res) === false ? res.statusCode : 'ERR'
          }, message);
        })();
      }
    });
    req.on('error', function (_err) {
      // FIXME: _verdaccio_aborted seems not used
      // @ts-ignore
      if (!req._verdaccio_aborted && !statusCalled) {
        statusCalled = true;

        self._statusCheck(false);
      }
    }); // @ts-ignore

    return req;
  }
  /**
   * Set default headers.
   * @param {Object} options
   * @return {Object}
   * @private
   */


  _setHeaders(options) {
    var _options$req;

    const headers = options.headers || {};
    const accept = _constants.HEADERS.ACCEPT;
    const acceptEncoding = _constants.HEADERS.ACCEPT_ENCODING;
    const userAgent = _constants.HEADERS.USER_AGENT;
    headers[accept] = headers[accept] || contentTypeAccept;
    headers[acceptEncoding] = headers[acceptEncoding] || 'gzip'; // registry.npmjs.org will only return search result if user-agent include string 'npm'

    headers[userAgent] = this.userAgent ? `npm (${this.userAgent})` : (_options$req = options.req) === null || _options$req === void 0 ? void 0 : _options$req.get('user-agent');
    return this._setAuth(headers);
  }
  /**
   * Validate configuration auth and assign Header authorization
   * @param {Object} headers
   * @return {Object}
   * @private
   */


  _setAuth(headers) {
    const {
      auth
    } = this.config;

    if (_lodash.default.isNil(auth) || headers[_constants.HEADERS.AUTHORIZATION]) {
      return headers;
    }

    if (_lodash.default.isObject(auth) === false && _lodash.default.isObject(auth.token) === false) {
      this._throwErrorAuth('Auth invalid');
    } // get NPM_TOKEN http://blog.npmjs.org/post/118393368555/deploying-with-npm-private-modules
    // or get other variable export in env
    // https://github.com/verdaccio/verdaccio/releases/tag/v2.5.0


    let token;
    const tokenConf = auth;

    if (_lodash.default.isNil(tokenConf.token) === false && _lodash.default.isString(tokenConf.token)) {
      token = tokenConf.token;
    } else if (_lodash.default.isNil(tokenConf.token_env) === false) {
      if (_lodash.default.isString(tokenConf.token_env)) {
        token = process.env[tokenConf.token_env];
      } else if (_lodash.default.isBoolean(tokenConf.token_env) && tokenConf.token_env) {
        token = process.env.NPM_TOKEN;
      } else {
        this.logger.error(_constants.ERROR_CODE.token_required);

        this._throwErrorAuth(_constants.ERROR_CODE.token_required);
      }
    } else {
      token = process.env.NPM_TOKEN;
    }

    if (_lodash.default.isNil(token)) {
      this._throwErrorAuth(_constants.ERROR_CODE.token_required);
    } // define type Auth allow basic and bearer


    const type = tokenConf.type || _constants.TOKEN_BASIC;

    this._setHeaderAuthorization(headers, type, token);

    return headers;
  }
  /**
   * @param {string} message
   * @throws {Error}
   * @private
   */


  _throwErrorAuth(message) {
    this.logger.error(message);
    throw new Error(message);
  }
  /**
   * Assign Header authorization with type authentication
   * @param {Object} headers
   * @param {string} type
   * @param {string} token
   * @private
   */


  _setHeaderAuthorization(headers, type, token) {
    const _type = type.toLowerCase();

    if (_type !== _constants.TOKEN_BEARER.toLowerCase() && _type !== _constants.TOKEN_BASIC.toLowerCase()) {
      this._throwErrorAuth(`Auth type '${_type}' not allowed`);
    }

    type = _lodash.default.upperFirst(type);
    headers[_constants.HEADERS.AUTHORIZATION] = (0, _utils.buildToken)(type, token);
  }
  /**
   * It will add or override specified headers from config file.
   *
   * Eg:
   *
   * uplinks:
   npmjs:
   url: https://registry.npmjs.org/
   headers:
   Accept: "application/vnd.npm.install-v2+json; q=1.0"
   verdaccio-staging:
   url: https://mycompany.com/npm
   headers:
   Accept: "application/json"
   authorization: "Basic YourBase64EncodedCredentials=="
    * @param {Object} headers
   * @private
   */


  _overrideWithUpLinkConfLocaligHeaders(headers) {
    if (!this.config.headers) {
      return headers;
    } // add/override headers specified in the config

    /* eslint guard-for-in: 0 */


    for (const key in this.config.headers) {
      headers[key] = this.config.headers[key];
    }
  }
  /**
   * Determine whether can fetch from the provided URL
   * @param {*} url
   * @return {Boolean}
   */


  isUplinkValid(url) {
    // $FlowFixMe
    const urlParsed = _url.default.parse(url);

    const isHTTPS = urlDomainParsed => urlDomainParsed.protocol === 'https:' && (urlParsed.port === null || urlParsed.port === '443');

    const getHost = urlDomainParsed => isHTTPS(urlDomainParsed) ? urlDomainParsed.hostname : urlDomainParsed.host;

    const isMatchProtocol = urlParsed.protocol === this.url.protocol;
    const isMatchHost = getHost(urlParsed) === getHost(this.url); // @ts-ignore

    const isMatchPath = urlParsed.path.indexOf(this.url.path) === 0;
    return isMatchProtocol && isMatchHost && isMatchPath;
  }
  /**
   * Get a remote package metadata
   * @param {*} name package name
   * @param {*} options request options, eg: eTag.
   * @param {*} callback
   */


  getRemoteMetadata(name, options, callback) {
    const headers = {};

    if (_lodash.default.isNil(options.etag) === false) {
      headers['If-None-Match'] = options.etag;
      headers[_constants.HEADERS.ACCEPT] = contentTypeAccept;
    }

    this.request({
      uri: `/${encode(name)}`,
      json: true,
      headers: headers,
      req: options.req
    }, (err, res, body) => {
      if (err) {
        return callback(err);
      }

      if (res.statusCode === _constants.HTTP_STATUS.NOT_FOUND) {
        return callback(_utils.ErrorCode.getNotFound(_constants.API_ERROR.NOT_PACKAGE_UPLINK));
      }

      if (!(res.statusCode >= _constants.HTTP_STATUS.OK && res.statusCode < _constants.HTTP_STATUS.MULTIPLE_CHOICES)) {
        const error = _utils.ErrorCode.getInternalError(`${_constants.API_ERROR.BAD_STATUS_CODE}: ${res.statusCode}`); // $FlowFixMe


        error.remoteStatus = res.statusCode;
        return callback(error);
      }

      callback(null, body, res.headers.etag);
    });
  }
  /**
   * Fetch a tarball from the uplink.
   * @param {String} url
   * @return {Stream}
   */


  fetchTarball(url) {
    const stream = new _streams.ReadTarball({});
    let current_length = 0;
    let expected_length;

    stream.abort = () => {};

    const readStream = this.request({
      uri_full: url,
      encoding: null,
      headers: {
        Accept: contentTypeAccept
      }
    });
    readStream.on('response', function (res) {
      if (res.statusCode === _constants.HTTP_STATUS.NOT_FOUND) {
        return stream.emit('error', _utils.ErrorCode.getNotFound(_constants.API_ERROR.NOT_FILE_UPLINK));
      }

      if (!(res.statusCode >= _constants.HTTP_STATUS.OK && res.statusCode < _constants.HTTP_STATUS.MULTIPLE_CHOICES)) {
        return stream.emit('error', _utils.ErrorCode.getInternalError(`bad uplink status code: ${res.statusCode}`));
      }

      if (res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH]) {
        expected_length = res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH];
        stream.emit(_constants.HEADER_TYPE.CONTENT_LENGTH, res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH]);
      }

      readStream.pipe(stream);
    });
    readStream.on('error', function (err) {
      stream.emit('error', err);
    });
    readStream.on('data', function (data) {
      current_length += data.length;
    });
    readStream.on('end', function (data) {
      if (data) {
        current_length += data.length;
      }

      if (expected_length && current_length != expected_length) {
        stream.emit('error', _utils.ErrorCode.getInternalError(_constants.API_ERROR.CONTENT_MISMATCH));
      }
    });
    return stream;
  }
  /**
   * Perform a stream search.
   * @param {*} options request options
   * @return {Stream}
   */


  search(options) {
    const transformStream = new _stream.default.PassThrough({
      objectMode: true
    });
    const requestStream = this.request({
      uri: options.req.url,
      req: options.req,
      headers: {
        // query for search
        referer: options.req.get('referer')
      }
    });

    const parsePackage = pkg => {
      if ((0, _utils.isObjectOrArray)(pkg)) {
        transformStream.emit('data', pkg);
      }
    };

    requestStream.on('response', res => {
      if (!String(res.statusCode).match(/^2\d\d$/)) {
        return transformStream.emit('error', _utils.ErrorCode.getInternalError(`bad status code ${res.statusCode} from uplink`));
      } // See https://github.com/request/request#requestoptions-callback
      // Request library will not decode gzip stream.


      let jsonStream;

      if (res.headers[_constants.HEADER_TYPE.CONTENT_ENCODING] === _constants.HEADERS.GZIP) {
        jsonStream = res.pipe(_zlib.default.createUnzip());
      } else {
        jsonStream = res;
      }

      jsonStream.pipe(_JSONStream.default.parse('*')).on('data', parsePackage);
      jsonStream.on('end', () => {
        transformStream.emit('end');
      });
    });
    requestStream.on('error', err => {
      transformStream.emit('error', err);
    });

    transformStream.abort = () => {
      // FIXME: this is clearly a potential issue
      // there is no abort method on Stream.Readable
      // @ts-ignore
      requestStream.abort();
      transformStream.emit('end');
    };

    return transformStream;
  }
  /**
   * Add proxy headers.
   * FIXME: object mutations, it should return an new object
   * @param {*} req the http request
   * @param {*} headers the request headers
   */


  _addProxyHeaders(req, headers) {
    if (req) {
      // Only submit X-Forwarded-For field if we don't have a proxy selected
      // in the config file.
      //
      // Otherwise misconfigured proxy could return 407:
      // https://github.com/rlidwka/sinopia/issues/254
      //
      // FIXME: proxy logic is odd, something is wrong here.
      // @ts-ignore
      if (!this.proxy) {
        headers['x-forwarded-for'] = (req.get('x-forwarded-for') ? req.get('x-forwarded-for') + ', ' : '') + req.connection.remoteAddress;
      }
    } // always attach Via header to avoid loops, even if we're not proxying


    headers['via'] = req && req.get('via') ? req.get('via') + ', ' : '';
    headers['via'] += '1.1 ' + this.server_id + ' (Verdaccio)';
  }
  /**
   * Check whether the remote host is available.
   * @param {*} alive
   * @return {Boolean}
   */


  _statusCheck(alive) {
    if (arguments.length === 0) {
      return this._ifRequestFailure() === false;
    }

    if (alive) {
      if (this.failed_requests >= this.max_fails) {
        this.logger.warn({
          host: this.url.host
        }, 'host @{host} is back online');
      }

      this.failed_requests = 0;
    } else {
      this.failed_requests++;

      if (this.failed_requests === this.max_fails) {
        this.logger.warn({
          host: this.url.host
        }, 'host @{host} is now offline');
      }
    }

    this.last_request_time = Date.now();
  }
  /**
   * If the request failure.
   * @return {boolean}
   * @private
   */


  _ifRequestFailure() {
    return this.failed_requests >= this.max_fails && Math.abs(Date.now() - this.last_request_time) < this.fail_timeout;
  }
  /**
   * Set up a proxy.
   * @param {*} hostname
   * @param {*} config
   * @param {*} mainconfig
   * @param {*} isHTTPS
   */


  _setupProxy(hostname, config, mainconfig, isHTTPS) {
    let noProxyList;
    const proxy_key = isHTTPS ? 'https_proxy' : 'http_proxy'; // get http_proxy and no_proxy configs

    if (proxy_key in config) {
      this.proxy = config[proxy_key];
    } else if (proxy_key in mainconfig) {
      this.proxy = mainconfig[proxy_key];
    }

    if ('no_proxy' in config) {
      // $FlowFixMe
      noProxyList = config.no_proxy;
    } else if ('no_proxy' in mainconfig) {
      noProxyList = mainconfig.no_proxy;
    } // use wget-like algorithm to determine if proxy shouldn't be used


    if (hostname[0] !== '.') {
      hostname = '.' + hostname;
    }

    if (_lodash.default.isString(noProxyList) && noProxyList.length) {
      // $FlowFixMe
      noProxyList = noProxyList.split(',');
    }

    if (_lodash.default.isArray(noProxyList)) {
      for (let i = 0; i < noProxyList.length; i++) {
        let noProxyItem = noProxyList[i];

        if (noProxyItem[0] !== '.') {
          noProxyItem = '.' + noProxyItem;
        }

        if (hostname.lastIndexOf(noProxyItem) === hostname.length - noProxyItem.length) {
          if (this.proxy) {
            debug('not using proxy for %o, excluded by %o rule', this.url.href, noProxyItem); // @ts-ignore

            this.proxy = false;
          }

          break;
        }
      }
    } // if it's non-string (i.e. "false"), don't use it


    if (_lodash.default.isString(this.proxy) === false) {
      // @ts-ignore
      delete this.proxy;
    } else {
      debug('using proxy %o for %o', this.url.href, this.proxy);
    }
  }

}

var _default = ProxyStorage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXAtc3RvcmFnZS50cyJdLCJuYW1lcyI6WyJkZWJ1ZyIsImVuY29kZSIsInRoaW5nIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImpzb25Db250ZW50VHlwZSIsIkhFQURFUlMiLCJKU09OIiwiY29udGVudFR5cGVBY2NlcHQiLCJzZXRDb25maWciLCJjb25maWciLCJrZXkiLCJkZWYiLCJfIiwiaXNOaWwiLCJQcm94eVN0b3JhZ2UiLCJjb25zdHJ1Y3RvciIsIm1haW5Db25maWciLCJmYWlsZWRfcmVxdWVzdHMiLCJ1c2VyQWdlbnQiLCJ1c2VyX2FnZW50IiwiY2EiLCJsb2dnZXIiLCJzZXJ2ZXJfaWQiLCJ1cmwiLCJVUkwiLCJwYXJzZSIsIl9zZXR1cFByb3h5IiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInRpbWVvdXQiLCJOdW1iZXIiLCJ3YXJuIiwiam9pbiIsIm1heGFnZSIsIm1heF9mYWlscyIsImZhaWxfdGltZW91dCIsInN0cmljdF9zc2wiLCJCb29sZWFuIiwiYWdlbnRfb3B0aW9ucyIsImtlZXBBbGl2ZSIsIm1heFNvY2tldHMiLCJtYXhGcmVlU29ja2V0cyIsInJlcXVlc3QiLCJvcHRpb25zIiwiY2IiLCJqc29uIiwiX3N0YXR1c0NoZWNrIiwic3RyZWFtUmVhZCIsIlN0cmVhbSIsIlJlYWRhYmxlIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiRXJyb3JDb2RlIiwiZ2V0SW50ZXJuYWxFcnJvciIsIkFQSV9FUlJPUiIsIlVQTElOS19PRkZMSU5FIiwiZW1pdCIsIl9yZWFkIiwib24iLCJzZWxmIiwiaGVhZGVycyIsIl9zZXRIZWFkZXJzIiwiX2FkZFByb3h5SGVhZGVycyIsInJlcSIsIl9vdmVycmlkZVdpdGhVcExpbmtDb25mTG9jYWxpZ0hlYWRlcnMiLCJtZXRob2QiLCJ1cmkiLCJ1cmlfZnVsbCIsImluZm8iLCJzdHJpbmdpZnkiLCJyZXF1ZXN0Q2FsbGJhY2siLCJlcnIiLCJyZXMiLCJib2R5IiwiZXJyb3IiLCJyZXNwb25zZUxlbmd0aCIsImxlbmd0aCIsInByb2Nlc3NCb2R5IiwibG9nQWN0aXZpdHkiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsInRvU3RyaW5nIiwiQ0hBUkFDVEVSX0VOQ09ESU5HIiwiVVRGOCIsIl9lcnIiLCJpc1N0cmluZyIsImh0dHAiLCJ1bmRlZmluZWQiLCJzdGF0dXMiLCJieXRlcyIsImluIiwib3V0IiwicmVxdWVzdE9wdGlvbnMiLCJwcm94eSIsImVuY29kaW5nIiwiZ3ppcCIsInN0cmljdFNTTCIsImFnZW50T3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsInN0YXR1c0NhbGxlZCIsIl92ZXJkYWNjaW9fYWJvcnRlZCIsImRvX2xvZyIsImlzTnVsbCIsImFjY2VwdCIsIkFDQ0VQVCIsImFjY2VwdEVuY29kaW5nIiwiQUNDRVBUX0VOQ09ESU5HIiwiVVNFUl9BR0VOVCIsImdldCIsIl9zZXRBdXRoIiwiYXV0aCIsIkFVVEhPUklaQVRJT04iLCJpc09iamVjdCIsInRva2VuIiwiX3Rocm93RXJyb3JBdXRoIiwidG9rZW5Db25mIiwidG9rZW5fZW52IiwiZW52IiwiaXNCb29sZWFuIiwiTlBNX1RPS0VOIiwiRVJST1JfQ09ERSIsInRva2VuX3JlcXVpcmVkIiwidHlwZSIsIlRPS0VOX0JBU0lDIiwiX3NldEhlYWRlckF1dGhvcml6YXRpb24iLCJFcnJvciIsIl90eXBlIiwidG9Mb3dlckNhc2UiLCJUT0tFTl9CRUFSRVIiLCJ1cHBlckZpcnN0IiwiaXNVcGxpbmtWYWxpZCIsInVybFBhcnNlZCIsImlzSFRUUFMiLCJ1cmxEb21haW5QYXJzZWQiLCJwb3J0IiwiZ2V0SG9zdCIsImhvc3QiLCJpc01hdGNoUHJvdG9jb2wiLCJpc01hdGNoSG9zdCIsImlzTWF0Y2hQYXRoIiwicGF0aCIsImluZGV4T2YiLCJnZXRSZW1vdGVNZXRhZGF0YSIsIm5hbWUiLCJjYWxsYmFjayIsImV0YWciLCJIVFRQX1NUQVRVUyIsIk5PVF9GT1VORCIsImdldE5vdEZvdW5kIiwiTk9UX1BBQ0tBR0VfVVBMSU5LIiwiT0siLCJNVUxUSVBMRV9DSE9JQ0VTIiwiQkFEX1NUQVRVU19DT0RFIiwicmVtb3RlU3RhdHVzIiwiZmV0Y2hUYXJiYWxsIiwic3RyZWFtIiwiUmVhZFRhcmJhbGwiLCJjdXJyZW50X2xlbmd0aCIsImV4cGVjdGVkX2xlbmd0aCIsImFib3J0IiwicmVhZFN0cmVhbSIsIkFjY2VwdCIsIk5PVF9GSUxFX1VQTElOSyIsIkhFQURFUl9UWVBFIiwiQ09OVEVOVF9MRU5HVEgiLCJwaXBlIiwiZGF0YSIsIkNPTlRFTlRfTUlTTUFUQ0giLCJzZWFyY2giLCJ0cmFuc2Zvcm1TdHJlYW0iLCJQYXNzVGhyb3VnaCIsIm9iamVjdE1vZGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVmZXJlciIsInBhcnNlUGFja2FnZSIsInBrZyIsIlN0cmluZyIsIm1hdGNoIiwianNvblN0cmVhbSIsIkNPTlRFTlRfRU5DT0RJTkciLCJHWklQIiwiemxpYiIsImNyZWF0ZVVuemlwIiwiSlNPTlN0cmVhbSIsImNvbm5lY3Rpb24iLCJyZW1vdGVBZGRyZXNzIiwiYWxpdmUiLCJhcmd1bWVudHMiLCJfaWZSZXF1ZXN0RmFpbHVyZSIsImxhc3RfcmVxdWVzdF90aW1lIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJhYnMiLCJtYWluY29uZmlnIiwibm9Qcm94eUxpc3QiLCJwcm94eV9rZXkiLCJub19wcm94eSIsInNwbGl0IiwiaXNBcnJheSIsImkiLCJub1Byb3h5SXRlbSIsImxhc3RJbmRleE9mIiwiaHJlZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUlBOztBQUNBOztBQUNBOzs7O0FBRUEsTUFBTUEsS0FBSyxHQUFHLG9CQUFXLHNCQUFYLENBQWQ7O0FBRUEsTUFBTUMsTUFBTSxHQUFHLFVBQVVDLEtBQVYsRUFBeUI7QUFDdEMsU0FBT0Msa0JBQWtCLENBQUNELEtBQUQsQ0FBbEIsQ0FBMEJFLE9BQTFCLENBQWtDLE1BQWxDLEVBQTBDLEdBQTFD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V0FBcEI7QUFDRDs7QUFDRCxZQUFJL0ssUUFBUSxDQUFDZ0wsV0FBVCxDQUFxQkQsV0FBckIsTUFBc0MvSyxRQUFRLENBQUNpRCxNQUFULEdBQWtCOEgsV0FBVyxDQUFDOUgsTUFBeEUsRUFBZ0Y7QUFDOUUsY0FBSSxLQUFLaUIsS0FBVCxFQUFnQjtBQUNkOUYsWUFBQUEsS0FBSyxDQUFDLDZDQUFELEVBQWdELEtBQUt3QixHQUFMLENBQVNxTCxJQUF6RCxFQUErREYsV0FBL0QsQ0FBTCxDQURjLENBRWQ7O0FBQ0EsaUJBQUs3RyxLQUFMLEdBQWEsS0FBYjtBQUNEOztBQUNEO0FBQ0Q7QUFDRjtBQUNGLEtBMUN3RyxDQTRDekc7OztBQUNBLFFBQUlqRixnQkFBRXlFLFFBQUYsQ0FBVyxLQUFLUSxLQUFoQixNQUEyQixLQUEvQixFQUFzQztBQUNwQztBQUNBLGFBQU8sS0FBS0EsS0FBWjtBQUNELEtBSEQsTUFHTztBQUNMOUYsTUFBQUEsS0FBSyxDQUFDLHVCQUFELEVBQTBCLEtBQUt3QixHQUFMLENBQVNxTCxJQUFuQyxFQUF5QyxLQUFLL0csS0FBOUMsQ0FBTDtBQUNEO0FBQ0Y7O0FBM29Ca0M7O2VBOG9CdEIvRSxZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEpTT05TdHJlYW0gZnJvbSAnSlNPTlN0cmVhbSc7XG5pbXBvcnQgYnVpbGREZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHJlcXVlc3QgZnJvbSAncmVxdWVzdCc7XG5pbXBvcnQgU3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgVVJMLCB7IFVybFdpdGhTdHJpbmdRdWVyeSB9IGZyb20gJ3VybCc7XG5pbXBvcnQgemxpYiBmcm9tICd6bGliJztcblxuaW1wb3J0IHsgUmVhZFRhcmJhbGwgfSBmcm9tICdAdmVyZGFjY2lvL3N0cmVhbXMnO1xuaW1wb3J0IHsgQ2FsbGJhY2ssIENvbmZpZywgSGVhZGVycywgTG9nZ2VyLCBQYWNrYWdlIH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5cbmltcG9ydCB7IElQcm94eSwgVXBMaW5rQ29uZkxvY2FsIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgQVBJX0VSUk9SLCBDSEFSQUNURVJfRU5DT0RJTkcsIEVSUk9SX0NPREUsIEhFQURFUlMsIEhFQURFUl9UWVBFLCBIVFRQX1NUQVRVUywgVE9LRU5fQkFTSUMsIFRPS0VOX0JFQVJFUiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yQ29kZSwgYnVpbGRUb2tlbiwgaXNPYmplY3QsIGlzT2JqZWN0T3JBcnJheSwgcGFyc2VJbnRlcnZhbCB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBkZWJ1ZyA9IGJ1aWxkRGVidWcoJ3ZlcmRhY2Npbzp1cC1zdG9yYWdlJyk7XG5cbmNvbnN0IGVuY29kZSA9IGZ1bmN0aW9uICh0aGluZyk6IHN0cmluZyB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodGhpbmcpLnJlcGxhY2UoL14lNDAvLCAnQCcpO1xufTtcblxuY29uc3QganNvbkNvbnRlbnRUeXBlID0gSEVBREVSUy5KU09OO1xuY29uc3QgY29udGVudFR5cGVBY2NlcHQgPSBgJHtqc29uQ29udGVudFR5cGV9O2A7XG5cbi8qKlxuICogSnVzdCBhIGhlbHBlciAoYGNvbmZpZ1trZXldIHx8IGRlZmF1bHRgIGRvZXNuJ3Qgd29yayBiZWNhdXNlIG9mIHplcm9lcylcbiAqL1xuY29uc3Qgc2V0Q29uZmlnID0gKGNvbmZpZywga2V5LCBkZWYpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gXy5pc05pbChjb25maWdba2V5XSkgPT09IGZhbHNlID8gY29uZmlnW2tleV0gOiBkZWY7XG59O1xuXG4vKipcbiAqIEltcGxlbWVudHMgU3RvcmFnZSBpbnRlcmZhY2VcbiAqIChzYW1lIGZvciBzdG9yYWdlLmpzLCBsb2NhbC1zdG9yYWdlLmpzLCB1cC1zdG9yYWdlLmpzKVxuICovXG5jbGFzcyBQcm94eVN0b3JhZ2UgaW1wbGVtZW50cyBJUHJveHkge1xuICBwdWJsaWMgY29uZmlnOiBVcExpbmtDb25mTG9jYWw7XG4gIHB1YmxpYyBmYWlsZWRfcmVxdWVzdHM6IG51bWJlcjtcbiAgcHVibGljIHVzZXJBZ2VudDogc3RyaW5nO1xuICBwdWJsaWMgY2E6IHN0cmluZyB8IHZvaWQ7XG4gIHB1YmxpYyBsb2dnZXI6IExvZ2dlcjtcbiAgcHVibGljIHNlcnZlcl9pZDogc3RyaW5nO1xuICBwdWJsaWMgdXJsOiBhbnk7XG4gIHB1YmxpYyBtYXhhZ2U6IG51bWJlcjtcbiAgcHVibGljIHRpbWVvdXQ6IG51bWJlcjtcbiAgcHVibGljIG1heF9mYWlsczogbnVtYmVyO1xuICBwdWJsaWMgZmFpbF90aW1lb3V0OiBudW1iZXI7XG4gIHB1YmxpYyBhZ2VudF9vcHRpb25zOiBhbnk7XG4gIC8vIEZJWE1FOiB1cG5hbWUgaXMgYXNzaWduZWQgdG8gZWFjaCBpbnN0YW5jZVxuICAvLyBAdHMtaWdub3JlXG4gIHB1YmxpYyB1cG5hbWU6IHN0cmluZztcbiAgLy8gRklYTUU6IHByb3h5IGNhbiBiZSBib29sZWFuIG9yIG9iamVjdCwgc29tZXRoaW5nIHNtZWxscyBoZXJlXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHVibGljIHByb3h5OiBzdHJpbmcgfCB2b2lkO1xuICAvLyBAdHMtaWdub3JlXG4gIHB1YmxpYyBsYXN0X3JlcXVlc3RfdGltZTogbnVtYmVyIHwgbnVsbDtcbiAgcHVibGljIHN0cmljdF9zc2w6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Kn0gY29uZmlnXG4gICAqIEBwYXJhbSB7Kn0gbWFpbkNvbmZpZ1xuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKGNvbmZpZzogVXBMaW5rQ29uZkxvY2FsLCBtYWluQ29uZmlnOiBDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmZhaWxlZF9yZXF1ZXN0cyA9IDA7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMudXNlckFnZW50ID0gbWFpbkNvbmZpZy51c2VyX2FnZW50O1xuICAgIHRoaXMuY2EgPSBjb25maWcuY2E7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5zZXJ2ZXJfaWQgPSBtYWluQ29uZmlnLnNlcnZlcl9pZDtcblxuICAgIHRoaXMudXJsID0gVVJMLnBhcnNlKHRoaXMuY29uZmlnLnVybCk7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHRoaXMuX3NldHVwUHJveHkodGhpcy51cmwuaG9zdG5hbWUsIGNvbmZpZywgbWFpbkNvbmZpZywgdGhpcy51cmwucHJvdG9jb2wgPT09ICdodHRwczonKTtcblxuICAgIHRoaXMuY29uZmlnLnVybCA9IHRoaXMuY29uZmlnLnVybC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnRpbWVvdXQgJiYgTnVtYmVyKHRoaXMuY29uZmlnLnRpbWVvdXQpID49IDEwMDApIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXG4gICAgICAgIFtcbiAgICAgICAgICAnVG9vIGJpZyB0aW1lb3V0IHZhbHVlOiAnICsgdGhpcy5jb25maWcudGltZW91dCxcbiAgICAgICAgICAnV2UgY2hhbmdlZCB0aW1lIGZvcm1hdCB0byBuZ2lueC1saWtlIG9uZScsXG4gICAgICAgICAgJyhzZWUgaHR0cDovL25naW54Lm9yZy9lbi9kb2NzL3N5bnRheC5odG1sKScsXG4gICAgICAgICAgJ3NvIHBsZWFzZSB1cGRhdGUgeW91ciBjb25maWcgYWNjb3JkaW5nbHknLFxuICAgICAgICBdLmpvaW4oJ1xcbicpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGEgYnVuY2ggb2YgZGlmZmVyZW50IGNvbmZpZ3VyYWJsZSB0aW1lcnNcbiAgICB0aGlzLm1heGFnZSA9IHBhcnNlSW50ZXJ2YWwoc2V0Q29uZmlnKHRoaXMuY29uZmlnLCAnbWF4YWdlJywgJzJtJykpO1xuICAgIHRoaXMudGltZW91dCA9IHBhcnNlSW50ZXJ2YWwoc2V0Q29uZmlnKHRoaXMuY29uZmlnLCAndGltZW91dCcsICczMHMnKSk7XG4gICAgdGhpcy5tYXhfZmFpbHMgPSBOdW1iZXIoc2V0Q29uZmlnKHRoaXMuY29uZmlnLCAnbWF4X2ZhaWxzJywgMikpO1xuICAgIHRoaXMuZmFpbF90aW1lb3V0ID0gcGFyc2VJbnRlcnZhbChzZXRDb25maWcodGhpcy5jb25maWcsICdmYWlsX3RpbWVvdXQnLCAnNW0nKSk7XG4gICAgdGhpcy5zdHJpY3Rfc3NsID0gQm9vbGVhbihzZXRDb25maWcodGhpcy5jb25maWcsICdzdHJpY3Rfc3NsJywgdHJ1ZSkpO1xuICAgIHRoaXMuYWdlbnRfb3B0aW9ucyA9IHNldENvbmZpZyh0aGlzLmNvbmZpZywgJ2FnZW50X29wdGlvbnMnLCB7XG4gICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICBtYXhTb2NrZXRzOiA0MCxcbiAgICAgIG1heEZyZWVTb2NrZXRzOiAxMCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbiBhc3NldC5cbiAgICogQHBhcmFtIHsqfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Kn0gY2JcbiAgICogQHJldHVybiB7UmVxdWVzdH1cbiAgICovXG4gIHByaXZhdGUgcmVxdWVzdChvcHRpb25zOiBhbnksIGNiPzogQ2FsbGJhY2spOiBTdHJlYW0uUmVhZGFibGUge1xuICAgIGxldCBqc29uO1xuXG4gICAgaWYgKHRoaXMuX3N0YXR1c0NoZWNrKCkgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBzdHJlYW1SZWFkID0gbmV3IFN0cmVhbS5SZWFkYWJsZSgpO1xuXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoQVBJX0VSUk9SLlVQTElOS19PRkZMSU5FKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtUmVhZC5lbWl0KCdlcnJvcicsIEVycm9yQ29kZS5nZXRJbnRlcm5hbEVycm9yKEFQSV9FUlJPUi5VUExJTktfT0ZGTElORSkpO1xuICAgICAgfSk7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBzdHJlYW1SZWFkLl9yZWFkID0gZnVuY3Rpb24gKCk6IHZvaWQge307XG4gICAgICAvLyBwcmV2ZW50aW5nICdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50J1xuICAgICAgc3RyZWFtUmVhZC5vbignZXJyb3InLCBmdW5jdGlvbiAoKTogdm9pZCB7fSk7XG4gICAgICByZXR1cm4gc3RyZWFtUmVhZDtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBoZWFkZXJzOiBIZWFkZXJzID0gdGhpcy5fc2V0SGVhZGVycyhvcHRpb25zKTtcblxuICAgIHRoaXMuX2FkZFByb3h5SGVhZGVycyhvcHRpb25zLnJlcSwgaGVhZGVycyk7XG4gICAgdGhpcy5fb3ZlcnJpZGVXaXRoVXBMaW5rQ29uZkxvY2FsaWdIZWFkZXJzKGhlYWRlcnMpO1xuXG4gICAgY29uc3QgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCc7XG4gICAgY29uc3QgdXJpID0gb3B0aW9ucy51cmlfZnVsbCB8fCB0aGlzLmNvbmZpZy51cmwgKyBvcHRpb25zLnVyaTtcblxuICAgIHNlbGYubG9nZ2VyLmluZm8oXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICB1cmk6IHVyaSxcbiAgICAgIH0sXG4gICAgICBcIm1ha2luZyByZXF1ZXN0OiAnQHttZXRob2R9IEB7dXJpfSdcIlxuICAgICk7XG5cbiAgICBpZiAoaXNPYmplY3Qob3B0aW9ucy5qc29uKSkge1xuICAgICAganNvbiA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbik7XG4gICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddIHx8IEhFQURFUlMuSlNPTjtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0Q2FsbGJhY2sgPSBjYlxuICAgICAgPyBmdW5jdGlvbiAoZXJyLCByZXMsIGJvZHkpOiB2b2lkIHtcbiAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VMZW5ndGggPSBlcnIgPyAwIDogYm9keS5sZW5ndGg7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICAgIHByb2Nlc3NCb2R5KCk7XG4gICAgICAgICAgbG9nQWN0aXZpdHkoKTtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgY2IoZXJyLCByZXMsIGJvZHkpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUGVyZm9ybSBhIGRlY29kZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQm9keSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5qc29uICYmIHJlcy5zdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkudG9TdHJpbmcoQ0hBUkFDVEVSX0VOQ09ESU5HLlVURjgpKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB7fTtcbiAgICAgICAgICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFlcnIgJiYgaXNPYmplY3QoYm9keSkpIHtcbiAgICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoYm9keS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGJvZHkuZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUGVyZm9ybSBhIGxvZy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbiBsb2dBY3Rpdml0eSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJAeyFzdGF0dXN9LCByZXE6ICdAe3JlcXVlc3QubWV0aG9kfSBAe3JlcXVlc3QudXJsfSdcIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IgPyAnLCBlcnJvcjogQHshZXJyb3J9JyA6ICcsIGJ5dGVzOiBAe2J5dGVzLmlufS9Ae2J5dGVzLm91dH0nO1xuICAgICAgICAgICAgc2VsZi5sb2dnZXIuaHR0cChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVycjogZXJyIHx8IHVuZGVmaW5lZCwgLy8gaWYgZXJyb3IgaXMgbnVsbC9mYWxzZSBjaGFuZ2UgdGhpcyB0byB1bmRlZmluZWQgc28gaXQgd29udCBsb2dcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZDogbWV0aG9kLCB1cmw6IHVyaSB9LFxuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzICE9IG51bGwgPyByZXMuc3RhdHVzQ29kZSA6ICdFUlInLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBieXRlczoge1xuICAgICAgICAgICAgICAgICAgaW46IGpzb24gPyBqc29uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgICAgICAgICBvdXQ6IHJlc3BvbnNlTGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgdXJsOiB1cmksXG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBib2R5OiBqc29uLFxuICAgICAgcHJveHk6IHRoaXMucHJveHksXG4gICAgICBlbmNvZGluZzogbnVsbCxcbiAgICAgIGd6aXA6IHRydWUsXG4gICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXQsXG4gICAgICBzdHJpY3RTU0w6IHRoaXMuc3RyaWN0X3NzbCxcbiAgICAgIGFnZW50T3B0aW9uczogdGhpcy5hZ2VudF9vcHRpb25zLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5jYSkge1xuICAgICAgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0T3B0aW9ucywge1xuICAgICAgICBjYTogdGhpcy5jYSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcSA9IHJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIHJlcXVlc3RDYWxsYmFjayk7XG5cbiAgICBsZXQgc3RhdHVzQ2FsbGVkID0gZmFsc2U7XG4gICAgcmVxLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uIChyZXMpOiB2b2lkIHtcbiAgICAgIC8vIEZJWE1FOiBfdmVyZGFjY2lvX2Fib3J0ZWQgc2VlbXMgbm90IHVzZWRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICghcmVxLl92ZXJkYWNjaW9fYWJvcnRlZCAmJiAhc3RhdHVzQ2FsbGVkKSB7XG4gICAgICAgIHN0YXR1c0NhbGxlZCA9IHRydWU7XG4gICAgICAgIHNlbGYuX3N0YXR1c0NoZWNrKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc05pbChyZXF1ZXN0Q2FsbGJhY2spID09PSBmYWxzZSkge1xuICAgICAgICAoZnVuY3Rpb24gZG9fbG9nKCk6IHZvaWQge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIkB7IXN0YXR1c30sIHJlcTogJ0B7cmVxdWVzdC5tZXRob2R9IEB7cmVxdWVzdC51cmx9JyAoc3RyZWFtaW5nKVwiO1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmh0dHAoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RhdHVzOiBfLmlzTnVsbChyZXMpID09PSBmYWxzZSA/IHJlcy5zdGF0dXNDb2RlIDogJ0VSUicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChfZXJyKTogdm9pZCB7XG4gICAgICAvLyBGSVhNRTogX3ZlcmRhY2Npb19hYm9ydGVkIHNlZW1zIG5vdCB1c2VkXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAoIXJlcS5fdmVyZGFjY2lvX2Fib3J0ZWQgJiYgIXN0YXR1c0NhbGxlZCkge1xuICAgICAgICBzdGF0dXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLl9zdGF0dXNDaGVjayhmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiByZXE7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgaGVhZGVycy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0SGVhZGVycyhvcHRpb25zOiBhbnkpOiBIZWFkZXJzIHtcbiAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIGNvbnN0IGFjY2VwdCA9IEhFQURFUlMuQUNDRVBUO1xuICAgIGNvbnN0IGFjY2VwdEVuY29kaW5nID0gSEVBREVSUy5BQ0NFUFRfRU5DT0RJTkc7XG4gICAgY29uc3QgdXNlckFnZW50ID0gSEVBREVSUy5VU0VSX0FHRU5UO1xuXG4gICAgaGVhZGVyc1thY2NlcHRdID0gaGVhZGVyc1thY2NlcHRdIHx8IGNvbnRlbnRUeXBlQWNjZXB0O1xuICAgIGhlYWRlcnNbYWNjZXB0RW5jb2RpbmddID0gaGVhZGVyc1thY2NlcHRFbmNvZGluZ10gfHwgJ2d6aXAnO1xuICAgIC8vIHJlZ2lzdHJ5Lm5wbWpzLm9yZyB3aWxsIG9ubHkgcmV0dXJuIHNlYXJjaCByZXN1bHQgaWYgdXNlci1hZ2VudCBpbmNsdWRlIHN0cmluZyAnbnBtJ1xuICAgIGhlYWRlcnNbdXNlckFnZW50XSA9IHRoaXMudXNlckFnZW50ID8gYG5wbSAoJHt0aGlzLnVzZXJBZ2VudH0pYCA6IG9wdGlvbnMucmVxPy5nZXQoJ3VzZXItYWdlbnQnKTtcblxuICAgIHJldHVybiB0aGlzLl9zZXRBdXRoKGhlYWRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGNvbmZpZ3VyYXRpb24gYXV0aCBhbmQgYXNzaWduIEhlYWRlciBhdXRob3JpemF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3NldEF1dGgoaGVhZGVyczogYW55KTogSGVhZGVycyB7XG4gICAgY29uc3QgeyBhdXRoIH0gPSB0aGlzLmNvbmZpZztcblxuICAgIGlmIChfLmlzTmlsKGF1dGgpIHx8IGhlYWRlcnNbSEVBREVSUy5BVVRIT1JJWkFUSU9OXSkge1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNPYmplY3QoYXV0aCkgPT09IGZhbHNlICYmIF8uaXNPYmplY3QoYXV0aC50b2tlbikgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl90aHJvd0Vycm9yQXV0aCgnQXV0aCBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IE5QTV9UT0tFTiBodHRwOi8vYmxvZy5ucG1qcy5vcmcvcG9zdC8xMTgzOTMzNjg1NTUvZGVwbG95aW5nLXdpdGgtbnBtLXByaXZhdGUtbW9kdWxlc1xuICAgIC8vIG9yIGdldCBvdGhlciB2YXJpYWJsZSBleHBvcnQgaW4gZW52XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmRhY2Npby92ZXJkYWNjaW8vcmVsZWFzZXMvdGFnL3YyLjUuMFxuICAgIGxldCB0b2tlbjogYW55O1xuICAgIGNvbnN0IHRva2VuQ29uZjogYW55ID0gYXV0aDtcblxuICAgIGlmIChfLmlzTmlsKHRva2VuQ29uZi50b2tlbikgPT09IGZhbHNlICYmIF8uaXNTdHJpbmcodG9rZW5Db25mLnRva2VuKSkge1xuICAgICAgdG9rZW4gPSB0b2tlbkNvbmYudG9rZW47XG4gICAgfSBlbHNlIGlmIChfLmlzTmlsKHRva2VuQ29uZi50b2tlbl9lbnYpID09PSBmYWxzZSkge1xuICAgICAgaWYgKF8uaXNTdHJpbmcodG9rZW5Db25mLnRva2VuX2VudikpIHtcbiAgICAgICAgdG9rZW4gPSBwcm9jZXNzLmVudlt0b2tlbkNvbmYudG9rZW5fZW52XTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc0Jvb2xlYW4odG9rZW5Db25mLnRva2VuX2VudikgJiYgdG9rZW5Db25mLnRva2VuX2Vudikge1xuICAgICAgICB0b2tlbiA9IHByb2Nlc3MuZW52Lk5QTV9UT0tFTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKEVSUk9SX0NPREUudG9rZW5fcmVxdWlyZWQpO1xuICAgICAgICB0aGlzLl90aHJvd0Vycm9yQXV0aChFUlJPUl9DT0RFLnRva2VuX3JlcXVpcmVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW4gPSBwcm9jZXNzLmVudi5OUE1fVE9LRU47XG4gICAgfVxuXG4gICAgaWYgKF8uaXNOaWwodG9rZW4pKSB7XG4gICAgICB0aGlzLl90aHJvd0Vycm9yQXV0aChFUlJPUl9DT0RFLnRva2VuX3JlcXVpcmVkKTtcbiAgICB9XG5cbiAgICAvLyBkZWZpbmUgdHlwZSBBdXRoIGFsbG93IGJhc2ljIGFuZCBiZWFyZXJcbiAgICBjb25zdCB0eXBlID0gdG9rZW5Db25mLnR5cGUgfHwgVE9LRU5fQkFTSUM7XG4gICAgdGhpcy5fc2V0SGVhZGVyQXV0aG9yaXphdGlvbihoZWFkZXJzLCB0eXBlLCB0b2tlbik7XG5cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3Rocm93RXJyb3JBdXRoKG1lc3NhZ2U6IHN0cmluZyk6IEVycm9yIHtcbiAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogQXNzaWduIEhlYWRlciBhdXRob3JpemF0aW9uIHdpdGggdHlwZSBhdXRoZW50aWNhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3NldEhlYWRlckF1dGhvcml6YXRpb24oaGVhZGVyczogYW55LCB0eXBlOiBzdHJpbmcsIHRva2VuOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBfdHlwZTogc3RyaW5nID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKF90eXBlICE9PSBUT0tFTl9CRUFSRVIudG9Mb3dlckNhc2UoKSAmJiBfdHlwZSAhPT0gVE9LRU5fQkFTSUMudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhpcy5fdGhyb3dFcnJvckF1dGgoYEF1dGggdHlwZSAnJHtfdHlwZX0nIG5vdCBhbGxvd2VkYCk7XG4gICAgfVxuXG4gICAgdHlwZSA9IF8udXBwZXJGaXJzdCh0eXBlKTtcbiAgICBoZWFkZXJzW0hFQURFUlMuQVVUSE9SSVpBVElPTl0gPSBidWlsZFRva2VuKHR5cGUsIHRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCB3aWxsIGFkZCBvciBvdmVycmlkZSBzcGVjaWZpZWQgaGVhZGVycyBmcm9tIGNvbmZpZyBmaWxlLlxuICAgKlxuICAgKiBFZzpcbiAgICpcbiAgICogdXBsaW5rczpcbiAgIG5wbWpzOlxuICAgdXJsOiBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9cbiAgIGhlYWRlcnM6XG4gICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vdm5kLm5wbS5pbnN0YWxsLXYyK2pzb247IHE9MS4wXCJcbiAgIHZlcmRhY2Npby1zdGFnaW5nOlxuICAgdXJsOiBodHRwczovL215Y29tcGFueS5jb20vbnBtXG4gICBoZWFkZXJzOlxuICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgYXV0aG9yaXphdGlvbjogXCJCYXNpYyBZb3VyQmFzZTY0RW5jb2RlZENyZWRlbnRpYWxzPT1cIlxuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9vdmVycmlkZVdpdGhVcExpbmtDb25mTG9jYWxpZ0hlYWRlcnMoaGVhZGVyczogSGVhZGVycyk6IGFueSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5oZWFkZXJzKSB7XG4gICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG5cbiAgICAvLyBhZGQvb3ZlcnJpZGUgaGVhZGVycyBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZ1xuICAgIC8qIGVzbGludCBndWFyZC1mb3ItaW46IDAgKi9cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNvbmZpZy5oZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzW2tleV0gPSB0aGlzLmNvbmZpZy5oZWFkZXJzW2tleV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGNhbiBmZXRjaCBmcm9tIHRoZSBwcm92aWRlZCBVUkxcbiAgICogQHBhcmFtIHsqfSB1cmxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHB1YmxpYyBpc1VwbGlua1ZhbGlkKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIGNvbnN0IHVybFBhcnNlZDogVXJsV2l0aFN0cmluZ1F1ZXJ5ID0gVVJMLnBhcnNlKHVybCk7XG4gICAgY29uc3QgaXNIVFRQUyA9ICh1cmxEb21haW5QYXJzZWQ6IFVSTCk6IGJvb2xlYW4gPT4gdXJsRG9tYWluUGFyc2VkLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiAodXJsUGFyc2VkLnBvcnQgPT09IG51bGwgfHwgdXJsUGFyc2VkLnBvcnQgPT09ICc0NDMnKTtcbiAgICBjb25zdCBnZXRIb3N0ID0gKHVybERvbWFpblBhcnNlZCk6IGJvb2xlYW4gPT4gKGlzSFRUUFModXJsRG9tYWluUGFyc2VkKSA/IHVybERvbWFpblBhcnNlZC5ob3N0bmFtZSA6IHVybERvbWFpblBhcnNlZC5ob3N0KTtcbiAgICBjb25zdCBpc01hdGNoUHJvdG9jb2w6IGJvb2xlYW4gPSB1cmxQYXJzZWQucHJvdG9jb2wgPT09IHRoaXMudXJsLnByb3RvY29sO1xuICAgIGNvbnN0IGlzTWF0Y2hIb3N0OiBib29sZWFuID0gZ2V0SG9zdCh1cmxQYXJzZWQpID09PSBnZXRIb3N0KHRoaXMudXJsKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgaXNNYXRjaFBhdGg6IGJvb2xlYW4gPSB1cmxQYXJzZWQucGF0aC5pbmRleE9mKHRoaXMudXJsLnBhdGgpID09PSAwO1xuXG4gICAgcmV0dXJuIGlzTWF0Y2hQcm90b2NvbCAmJiBpc01hdGNoSG9zdCAmJiBpc01hdGNoUGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZW1vdGUgcGFja2FnZSBtZXRhZGF0YVxuICAgKiBAcGFyYW0geyp9IG5hbWUgcGFja2FnZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gb3B0aW9ucyByZXF1ZXN0IG9wdGlvbnMsIGVnOiBlVGFnLlxuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgZ2V0UmVtb3RlTWV0YWRhdGEobmFtZTogc3RyaW5nLCBvcHRpb25zOiBhbnksIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAoXy5pc05pbChvcHRpb25zLmV0YWcpID09PSBmYWxzZSkge1xuICAgICAgaGVhZGVyc1snSWYtTm9uZS1NYXRjaCddID0gb3B0aW9ucy5ldGFnO1xuICAgICAgaGVhZGVyc1tIRUFERVJTLkFDQ0VQVF0gPSBjb250ZW50VHlwZUFjY2VwdDtcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3QoXG4gICAgICB7XG4gICAgICAgIHVyaTogYC8ke2VuY29kZShuYW1lKX1gLFxuICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICByZXE6IG9wdGlvbnMucmVxLFxuICAgICAgfSxcbiAgICAgIChlcnIsIHJlcywgYm9keSk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSBIVFRQX1NUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKEFQSV9FUlJPUi5OT1RfUEFDS0FHRV9VUExJTkspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShyZXMuc3RhdHVzQ29kZSA+PSBIVFRQX1NUQVRVUy5PSyAmJiByZXMuc3RhdHVzQ29kZSA8IEhUVFBfU1RBVFVTLk1VTFRJUExFX0NIT0lDRVMpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcihgJHtBUElfRVJST1IuQkFEX1NUQVRVU19DT0RFfTogJHtyZXMuc3RhdHVzQ29kZX1gKTtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgZXJyb3IucmVtb3RlU3RhdHVzID0gcmVzLnN0YXR1c0NvZGU7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBib2R5LCByZXMuaGVhZGVycy5ldGFnKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgdGFyYmFsbCBmcm9tIHRoZSB1cGxpbmsuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgZmV0Y2hUYXJiYWxsKHVybDogc3RyaW5nKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRUYXJiYWxsKHt9KTtcbiAgICBsZXQgY3VycmVudF9sZW5ndGggPSAwO1xuICAgIGxldCBleHBlY3RlZF9sZW5ndGg7XG5cbiAgICBzdHJlYW0uYWJvcnQgPSAoKSA9PiB7fTtcbiAgICBjb25zdCByZWFkU3RyZWFtID0gdGhpcy5yZXF1ZXN0KHtcbiAgICAgIHVyaV9mdWxsOiB1cmwsXG4gICAgICBlbmNvZGluZzogbnVsbCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQWNjZXB0OiBjb250ZW50VHlwZUFjY2VwdCxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZWFkU3RyZWFtLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uIChyZXM6IGFueSkge1xuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSBIVFRQX1NUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIEVycm9yQ29kZS5nZXROb3RGb3VuZChBUElfRVJST1IuTk9UX0ZJTEVfVVBMSU5LKSk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXMuc3RhdHVzQ29kZSA+PSBIVFRQX1NUQVRVUy5PSyAmJiByZXMuc3RhdHVzQ29kZSA8IEhUVFBfU1RBVFVTLk1VTFRJUExFX0NIT0lDRVMpKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcihgYmFkIHVwbGluayBzdGF0dXMgY29kZTogJHtyZXMuc3RhdHVzQ29kZX1gKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzLmhlYWRlcnNbSEVBREVSX1RZUEUuQ09OVEVOVF9MRU5HVEhdKSB7XG4gICAgICAgIGV4cGVjdGVkX2xlbmd0aCA9IHJlcy5oZWFkZXJzW0hFQURFUl9UWVBFLkNPTlRFTlRfTEVOR1RIXTtcbiAgICAgICAgc3RyZWFtLmVtaXQoSEVBREVSX1RZUEUuQ09OVEVOVF9MRU5HVEgsIHJlcy5oZWFkZXJzW0hFQURFUl9UWVBFLkNPTlRFTlRfTEVOR1RIXSk7XG4gICAgICB9XG5cbiAgICAgIHJlYWRTdHJlYW0ucGlwZShzdHJlYW0pO1xuICAgIH0pO1xuXG4gICAgcmVhZFN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuICAgIHJlYWRTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgY3VycmVudF9sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmVhZFN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGN1cnJlbnRfbGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVjdGVkX2xlbmd0aCAmJiBjdXJyZW50X2xlbmd0aCAhPSBleHBlY3RlZF9sZW5ndGgpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoQVBJX0VSUk9SLkNPTlRFTlRfTUlTTUFUQ0gpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBzdHJlYW0gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnMgcmVxdWVzdCBvcHRpb25zXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHB1YmxpYyBzZWFyY2gob3B0aW9uczogYW55KTogU3RyZWFtLlJlYWRhYmxlIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW06IGFueSA9IG5ldyBTdHJlYW0uUGFzc1Rocm91Z2goeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RTdHJlYW06IFN0cmVhbS5SZWFkYWJsZSA9IHRoaXMucmVxdWVzdCh7XG4gICAgICB1cmk6IG9wdGlvbnMucmVxLnVybCxcbiAgICAgIHJlcTogb3B0aW9ucy5yZXEsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC8vIHF1ZXJ5IGZvciBzZWFyY2hcbiAgICAgICAgcmVmZXJlcjogb3B0aW9ucy5yZXEuZ2V0KCdyZWZlcmVyJyksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgcGFyc2VQYWNrYWdlID0gKHBrZzogUGFja2FnZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGlzT2JqZWN0T3JBcnJheShwa2cpKSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmVhbS5lbWl0KCdkYXRhJywgcGtnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWVzdFN0cmVhbS5vbigncmVzcG9uc2UnLCAocmVzKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIVN0cmluZyhyZXMuc3RhdHVzQ29kZSkubWF0Y2goL14yXFxkXFxkJC8pKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1TdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcihgYmFkIHN0YXR1cyBjb2RlICR7cmVzLnN0YXR1c0NvZGV9IGZyb20gdXBsaW5rYCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlcXVlc3QvcmVxdWVzdCNyZXF1ZXN0b3B0aW9ucy1jYWxsYmFja1xuICAgICAgLy8gUmVxdWVzdCBsaWJyYXJ5IHdpbGwgbm90IGRlY29kZSBnemlwIHN0cmVhbS5cbiAgICAgIGxldCBqc29uU3RyZWFtO1xuICAgICAgaWYgKHJlcy5oZWFkZXJzW0hFQURFUl9UWVBFLkNPTlRFTlRfRU5DT0RJTkddID09PSBIRUFERVJTLkdaSVApIHtcbiAgICAgICAganNvblN0cmVhbSA9IHJlcy5waXBlKHpsaWIuY3JlYXRlVW56aXAoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uU3RyZWFtID0gcmVzO1xuICAgICAgfVxuICAgICAganNvblN0cmVhbS5waXBlKEpTT05TdHJlYW0ucGFyc2UoJyonKSkub24oJ2RhdGEnLCBwYXJzZVBhY2thZ2UpO1xuICAgICAganNvblN0cmVhbS5vbignZW5kJywgKCk6IHZvaWQgPT4ge1xuICAgICAgICB0cmFuc2Zvcm1TdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJlcXVlc3RTdHJlYW0ub24oJ2Vycm9yJywgKGVycjogRXJyb3IpOiB2b2lkID0+IHtcbiAgICAgIHRyYW5zZm9ybVN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICB0cmFuc2Zvcm1TdHJlYW0uYWJvcnQgPSAoKTogdm9pZCA9PiB7XG4gICAgICAvLyBGSVhNRTogdGhpcyBpcyBjbGVhcmx5IGEgcG90ZW50aWFsIGlzc3VlXG4gICAgICAvLyB0aGVyZSBpcyBubyBhYm9ydCBtZXRob2Qgb24gU3RyZWFtLlJlYWRhYmxlXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXF1ZXN0U3RyZWFtLmFib3J0KCk7XG4gICAgICB0cmFuc2Zvcm1TdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgfTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm1TdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogQWRkIHByb3h5IGhlYWRlcnMuXG4gICAqIEZJWE1FOiBvYmplY3QgbXV0YXRpb25zLCBpdCBzaG91bGQgcmV0dXJuIGFuIG5ldyBvYmplY3RcbiAgICogQHBhcmFtIHsqfSByZXEgdGhlIGh0dHAgcmVxdWVzdFxuICAgKiBAcGFyYW0geyp9IGhlYWRlcnMgdGhlIHJlcXVlc3QgaGVhZGVyc1xuICAgKi9cbiAgcHJpdmF0ZSBfYWRkUHJveHlIZWFkZXJzKHJlcTogYW55LCBoZWFkZXJzOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAocmVxKSB7XG4gICAgICAvLyBPbmx5IHN1Ym1pdCBYLUZvcndhcmRlZC1Gb3IgZmllbGQgaWYgd2UgZG9uJ3QgaGF2ZSBhIHByb3h5IHNlbGVjdGVkXG4gICAgICAvLyBpbiB0aGUgY29uZmlnIGZpbGUuXG4gICAgICAvL1xuICAgICAgLy8gT3RoZXJ3aXNlIG1pc2NvbmZpZ3VyZWQgcHJveHkgY291bGQgcmV0dXJuIDQwNzpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ybGlkd2thL3Npbm9waWEvaXNzdWVzLzI1NFxuICAgICAgLy9cbiAgICAgIC8vIEZJWE1FOiBwcm94eSBsb2dpYyBpcyBvZGQsIHNvbWV0aGluZyBpcyB3cm9uZyBoZXJlLlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKCF0aGlzLnByb3h5KSB7XG4gICAgICAgIGhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddID0gKHJlcS5nZXQoJ3gtZm9yd2FyZGVkLWZvcicpID8gcmVxLmdldCgneC1mb3J3YXJkZWQtZm9yJykgKyAnLCAnIDogJycpICsgcmVxLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbHdheXMgYXR0YWNoIFZpYSBoZWFkZXIgdG8gYXZvaWQgbG9vcHMsIGV2ZW4gaWYgd2UncmUgbm90IHByb3h5aW5nXG4gICAgaGVhZGVyc1sndmlhJ10gPSByZXEgJiYgcmVxLmdldCgndmlhJykgPyByZXEuZ2V0KCd2aWEnKSArICcsICcgOiAnJztcblxuICAgIGhlYWRlcnNbJ3ZpYSddICs9ICcxLjEgJyArIHRoaXMuc2VydmVyX2lkICsgJyAoVmVyZGFjY2lvKSc7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgcmVtb3RlIGhvc3QgaXMgYXZhaWxhYmxlLlxuICAgKiBAcGFyYW0geyp9IGFsaXZlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBwcml2YXRlIF9zdGF0dXNDaGVjayhhbGl2ZT86IGJvb2xlYW4pOiBib29sZWFuIHwgdm9pZCB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9pZlJlcXVlc3RGYWlsdXJlKCkgPT09IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWxpdmUpIHtcbiAgICAgIGlmICh0aGlzLmZhaWxlZF9yZXF1ZXN0cyA+PSB0aGlzLm1heF9mYWlscykge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMudXJsLmhvc3QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnaG9zdCBAe2hvc3R9IGlzIGJhY2sgb25saW5lJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5mYWlsZWRfcmVxdWVzdHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZhaWxlZF9yZXF1ZXN0cysrO1xuICAgICAgaWYgKHRoaXMuZmFpbGVkX3JlcXVlc3RzID09PSB0aGlzLm1heF9mYWlscykge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMudXJsLmhvc3QsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnaG9zdCBAe2hvc3R9IGlzIG5vdyBvZmZsaW5lJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGFzdF9yZXF1ZXN0X3RpbWUgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZXF1ZXN0IGZhaWx1cmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9pZlJlcXVlc3RGYWlsdXJlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZhaWxlZF9yZXF1ZXN0cyA+PSB0aGlzLm1heF9mYWlscyAmJiBNYXRoLmFicyhEYXRlLm5vdygpIC0gKHRoaXMubGFzdF9yZXF1ZXN0X3RpbWUgYXMgbnVtYmVyKSkgPCB0aGlzLmZhaWxfdGltZW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYSBwcm94eS5cbiAgICogQHBhcmFtIHsqfSBob3N0bmFtZVxuICAgKiBAcGFyYW0geyp9IGNvbmZpZ1xuICAgKiBAcGFyYW0geyp9IG1haW5jb25maWdcbiAgICogQHBhcmFtIHsqfSBpc0hUVFBTXG4gICAqL1xuICBwcml2YXRlIF9zZXR1cFByb3h5KGhvc3RuYW1lOiBzdHJpbmcsIGNvbmZpZzogVXBMaW5rQ29uZkxvY2FsLCBtYWluY29uZmlnOiBDb25maWcsIGlzSFRUUFM6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQgbm9Qcm94eUxpc3Q7XG4gICAgY29uc3QgcHJveHlfa2V5OiBzdHJpbmcgPSBpc0hUVFBTID8gJ2h0dHBzX3Byb3h5JyA6ICdodHRwX3Byb3h5JztcblxuICAgIC8vIGdldCBodHRwX3Byb3h5IGFuZCBub19wcm94eSBjb25maWdzXG4gICAgaWYgKHByb3h5X2tleSBpbiBjb25maWcpIHtcbiAgICAgIHRoaXMucHJveHkgPSBjb25maWdbcHJveHlfa2V5XTtcbiAgICB9IGVsc2UgaWYgKHByb3h5X2tleSBpbiBtYWluY29uZmlnKSB7XG4gICAgICB0aGlzLnByb3h5ID0gbWFpbmNvbmZpZ1twcm94eV9rZXldO1xuICAgIH1cbiAgICBpZiAoJ25vX3Byb3h5JyBpbiBjb25maWcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIG5vUHJveHlMaXN0ID0gY29uZmlnLm5vX3Byb3h5O1xuICAgIH0gZWxzZSBpZiAoJ25vX3Byb3h5JyBpbiBtYWluY29uZmlnKSB7XG4gICAgICBub1Byb3h5TGlzdCA9IG1haW5jb25maWcubm9fcHJveHk7XG4gICAgfVxuXG4gICAgLy8gdXNlIHdnZXQtbGlrZSBhbGdvcml0aG0gdG8gZGV0ZXJtaW5lIGlmIHByb3h5IHNob3VsZG4ndCBiZSB1c2VkXG4gICAgaWYgKGhvc3RuYW1lWzBdICE9PSAnLicpIHtcbiAgICAgIGhvc3RuYW1lID0gJy4nICsgaG9zdG5hbWU7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNTdHJpbmcobm9Qcm94eUxpc3QpICYmIG5vUHJveHlMaXN0Lmxlbmd0aCkge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgbm9Qcm94eUxpc3QgPSBub1Byb3h5TGlzdC5zcGxpdCgnLCcpO1xuICAgIH1cblxuICAgIGlmIChfLmlzQXJyYXkobm9Qcm94eUxpc3QpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vUHJveHlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub1Byb3h5SXRlbSA9IG5vUHJveHlMaXN0W2ldO1xuICAgICAgICBpZiAobm9Qcm94eUl0ZW1bMF0gIT09ICcuJykge1xuICAgICAgICAgIG5vUHJveHlJdGVtID0gJy4nICsgbm9Qcm94eUl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RuYW1lLmxhc3RJbmRleE9mKG5vUHJveHlJdGVtKSA9PT0gaG9zdG5hbWUubGVuZ3RoIC0gbm9Qcm94eUl0ZW0ubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJveHkpIHtcbiAgICAgICAgICAgIGRlYnVnKCdub3QgdXNpbmcgcHJveHkgZm9yICVvLCBleGNsdWRlZCBieSAlbyBydWxlJywgdGhpcy51cmwuaHJlZiwgbm9Qcm94eUl0ZW0pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5wcm94eSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGl0J3Mgbm9uLXN0cmluZyAoaS5lLiBcImZhbHNlXCIpLCBkb24ndCB1c2UgaXRcbiAgICBpZiAoXy5pc1N0cmluZyh0aGlzLnByb3h5KSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGRlbGV0ZSB0aGlzLnByb3h5O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygndXNpbmcgcHJveHkgJW8gZm9yICVvJywgdGhpcy51cmwuaHJlZiwgdGhpcy5wcm94eSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb3h5U3RvcmFnZTtcbiJdfQ==