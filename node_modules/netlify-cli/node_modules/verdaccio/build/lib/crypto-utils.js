"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.aesDecrypt = aesDecrypt;
exports.aesEncrypt = aesEncrypt;
exports.createTarballHash = createTarballHash;
exports.defaultTarballHashAlgorithm = exports.defaultAlgorithm = void 0;
exports.generateRandomHexString = generateRandomHexString;
exports.signPayload = signPayload;
exports.stringToMD5 = stringToMD5;
exports.verifyPayload = verifyPayload;

var _crypto = require("crypto");

var _jsonwebtoken = _interopRequireDefault(require("jsonwebtoken"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const defaultAlgorithm = 'aes192';
exports.defaultAlgorithm = defaultAlgorithm;
const defaultTarballHashAlgorithm = 'sha1';
exports.defaultTarballHashAlgorithm = defaultTarballHashAlgorithm;

function aesEncrypt(buf, secret) {
  // deprecated (it will be migrated in Verdaccio 5), it is a breaking change
  // https://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password_options
  // https://www.grainger.xyz/changing-from-cipher-to-cipheriv/
  const c = (0, _crypto.createCipher)(defaultAlgorithm, secret);
  const b1 = c.update(buf);
  const b2 = c.final();
  return Buffer.concat([b1, b2]);
}

function aesDecrypt(buf, secret) {
  try {
    // deprecated (it will be migrated in Verdaccio 5), it is a breaking change
    // https://nodejs.org/api/crypto.html#crypto_crypto_createdecipher_algorithm_password_options
    // https://www.grainger.xyz/changing-from-cipher-to-cipheriv/
    const c = (0, _crypto.createDecipher)(defaultAlgorithm, secret);
    const b1 = c.update(buf);
    const b2 = c.final();
    return Buffer.concat([b1, b2]);
  } catch (_) {
    return Buffer.alloc(0);
  }
}

function createTarballHash() {
  return (0, _crypto.createHash)(defaultTarballHashAlgorithm);
}
/**
 * Express doesn't do ETAGS with requests <= 1024b
 * we use md5 here, it works well on 1k+ bytes, but sucks with fewer data
 * could improve performance using crc32 after benchmarks.
 * @param {Object} data
 * @return {String}
 */


function stringToMD5(data) {
  return (0, _crypto.createHash)('md5').update(data).digest('hex');
}

function generateRandomHexString(length = 8) {
  return (0, _crypto.pseudoRandomBytes)(length).toString('hex');
}

async function signPayload(payload, secretOrPrivateKey, options) {
  return new Promise(function (resolve, reject) {
    return _jsonwebtoken.default.sign(payload, secretOrPrivateKey, _objectSpread({
      notBefore: '1'
    }, options), (error, token) => error ? reject(error) : resolve(token));
  });
}

function verifyPayload(token, secretOrPrivateKey) {
  return _jsonwebtoken.default.verify(token, secretOrPrivateKey);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY3J5cHRvLXV0aWxzLnRzIl0sIm5hbWVzIjpbImRlZmF1bHRBbGdvcml0aG0iLCJkZWZhdWx0VGFyYmFsbEhhc2hBbGdvcml0aG0iLCJhZXNFbmNyeXB0IiwiYnVmIiwic2VjcmV0IiwiYyIsImIxIiwidXBkYXRlIiwiYjIiLCJmaW5hbCIsIkJ1ZmZlciIsImNvbmNhdCIsImFlc0RlY3J5cHQiLCJfIiwiYWxsb2MiLCJjcmVhdGVUYXJiYWxsSGFzaCIsInN0cmluZ1RvTUQ1IiwiZGF0YSIsImRpZ2VzdCIsImdlbmVyYXRlUmFuZG9tSGV4U3RyaW5nIiwibGVuZ3RoIiwidG9TdHJpbmciLCJzaWduUGF5bG9hZCIsInBheWxvYWQiLCJzZWNyZXRPclByaXZhdGVLZXkiLCJvcHRpb25zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJqd3QiLCJzaWduIiwibm90QmVmb3JlIiwiZXJyb3IiLCJ0b2tlbiIsInZlcmlmeVBheWxvYWQiLCJ2ZXJpZnkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7Ozs7Ozs7QUFJTyxNQUFNQSxnQkFBZ0IsR0FBRyxRQUF6Qjs7QUFDQSxNQUFNQywyQkFBMkIsR0FBRyxNQUFwQzs7O0FBRUEsU0FBU0MsVUFBVCxDQUFvQkMsR0FBcEIsRUFBaUNDLE1BQWpDLEVBQXlEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLFFBQU1DLENBQUMsR0FBRywwQkFBYUwsZ0JBQWIsRUFBK0JJLE1BQS9CLENBQVY7QUFDQSxRQUFNRSxFQUFFLEdBQUdELENBQUMsQ0FBQ0UsTUFBRixDQUFTSixHQUFULENBQVg7QUFDQSxRQUFNSyxFQUFFLEdBQUdILENBQUMsQ0FBQ0ksS0FBRixFQUFYO0FBQ0EsU0FBT0MsTUFBTSxDQUFDQyxNQUFQLENBQWMsQ0FBQ0wsRUFBRCxFQUFLRSxFQUFMLENBQWQsQ0FBUDtBQUNEOztBQUVNLFNBQVNJLFVBQVQsQ0FBb0JULEdBQXBCLEVBQWlDQyxNQUFqQyxFQUF5RDtBQUM5RCxNQUFJO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsVUFBTUMsQ0FBQyxHQUFHLDRCQUFlTCxnQkFBZixFQUFpQ0ksTUFBakMsQ0FBVjtBQUNBLFVBQU1FLEVBQUUsR0FBR0QsQ0FBQyxDQUFDRSxNQUFGLENBQVNKLEdBQVQsQ0FBWDtBQUNBLFVBQU1LLEVBQUUsR0FBR0gsQ0FBQyxDQUFDSSxLQUFGLEVBQVg7QUFDQSxXQUFPQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxDQUFDTCxFQUFELEVBQUtFLEVBQUwsQ0FBZCxDQUFQO0FBQ0QsR0FSRCxDQVFFLE9BQU9LLENBQVAsRUFBVTtBQUNWLFdBQU9ILE1BQU0sQ0FBQ0ksS0FBUCxDQUFhLENBQWIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRU0sU0FBU0MsaUJBQVQsR0FBbUM7QUFDeEMsU0FBTyx3QkFBV2QsMkJBQVgsQ0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNlLFdBQVQsQ0FBcUJDLElBQXJCLEVBQW9EO0FBQ3pELFNBQU8sd0JBQVcsS0FBWCxFQUFrQlYsTUFBbEIsQ0FBeUJVLElBQXpCLEVBQStCQyxNQUEvQixDQUFzQyxLQUF0QyxDQUFQO0FBQ0Q7O0FBRU0sU0FBU0MsdUJBQVQsQ0FBaUNDLE1BQU0sR0FBRyxDQUExQyxFQUFxRDtBQUMxRCxTQUFPLCtCQUFrQkEsTUFBbEIsRUFBMEJDLFFBQTFCLENBQW1DLEtBQW5DLENBQVA7QUFDRDs7QUFFTSxlQUFlQyxXQUFmLENBQTJCQyxPQUEzQixFQUFnREMsa0JBQWhELEVBQTRFQyxPQUE1RSxFQUFzSDtBQUMzSCxTQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFVQyxPQUFWLEVBQW1CQyxNQUFuQixFQUE0QztBQUM3RCxXQUFPQyxzQkFBSUMsSUFBSixDQUNMUCxPQURLLEVBRUxDLGtCQUZLO0FBSUhPLE1BQUFBLFNBQVMsRUFBRTtBQUpSLE9BS0FOLE9BTEEsR0FPTCxDQUFDTyxLQUFELEVBQVFDLEtBQVIsS0FBbUJELEtBQUssR0FBR0osTUFBTSxDQUFDSSxLQUFELENBQVQsR0FBbUJMLE9BQU8sQ0FBQ00sS0FBRCxDQVA3QyxDQUFQO0FBU0QsR0FWTSxDQUFQO0FBV0Q7O0FBRU0sU0FBU0MsYUFBVCxDQUF1QkQsS0FBdkIsRUFBc0NULGtCQUF0QyxFQUE4RTtBQUNuRixTQUFPSyxzQkFBSU0sTUFBSixDQUFXRixLQUFYLEVBQWtCVCxrQkFBbEIsQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaCwgY3JlYXRlQ2lwaGVyLCBjcmVhdGVEZWNpcGhlciwgY3JlYXRlSGFzaCwgcHNldWRvUmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuXG5pbXBvcnQgeyBKV1RTaWduT3B0aW9ucywgUmVtb3RlVXNlciB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEFsZ29yaXRobSA9ICdhZXMxOTInO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRUYXJiYWxsSGFzaEFsZ29yaXRobSA9ICdzaGExJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFlc0VuY3J5cHQoYnVmOiBCdWZmZXIsIHNlY3JldDogc3RyaW5nKTogQnVmZmVyIHtcbiAgLy8gZGVwcmVjYXRlZCAoaXQgd2lsbCBiZSBtaWdyYXRlZCBpbiBWZXJkYWNjaW8gNSksIGl0IGlzIGEgYnJlYWtpbmcgY2hhbmdlXG4gIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjY3J5cHRvX2NyeXB0b19jcmVhdGVjaXBoZXJfYWxnb3JpdGhtX3Bhc3N3b3JkX29wdGlvbnNcbiAgLy8gaHR0cHM6Ly93d3cuZ3JhaW5nZXIueHl6L2NoYW5naW5nLWZyb20tY2lwaGVyLXRvLWNpcGhlcml2L1xuICBjb25zdCBjID0gY3JlYXRlQ2lwaGVyKGRlZmF1bHRBbGdvcml0aG0sIHNlY3JldCk7XG4gIGNvbnN0IGIxID0gYy51cGRhdGUoYnVmKTtcbiAgY29uc3QgYjIgPSBjLmZpbmFsKCk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtiMSwgYjJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFlc0RlY3J5cHQoYnVmOiBCdWZmZXIsIHNlY3JldDogc3RyaW5nKTogQnVmZmVyIHtcbiAgdHJ5IHtcbiAgICAvLyBkZXByZWNhdGVkIChpdCB3aWxsIGJlIG1pZ3JhdGVkIGluIFZlcmRhY2NpbyA1KSwgaXQgaXMgYSBicmVha2luZyBjaGFuZ2VcbiAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2NyeXB0b19jcnlwdG9fY3JlYXRlZGVjaXBoZXJfYWxnb3JpdGhtX3Bhc3N3b3JkX29wdGlvbnNcbiAgICAvLyBodHRwczovL3d3dy5ncmFpbmdlci54eXovY2hhbmdpbmctZnJvbS1jaXBoZXItdG8tY2lwaGVyaXYvXG4gICAgY29uc3QgYyA9IGNyZWF0ZURlY2lwaGVyKGRlZmF1bHRBbGdvcml0aG0sIHNlY3JldCk7XG4gICAgY29uc3QgYjEgPSBjLnVwZGF0ZShidWYpO1xuICAgIGNvbnN0IGIyID0gYy5maW5hbCgpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtiMSwgYjJdKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhcmJhbGxIYXNoKCk6IEhhc2gge1xuICByZXR1cm4gY3JlYXRlSGFzaChkZWZhdWx0VGFyYmFsbEhhc2hBbGdvcml0aG0pO1xufVxuXG4vKipcbiAqIEV4cHJlc3MgZG9lc24ndCBkbyBFVEFHUyB3aXRoIHJlcXVlc3RzIDw9IDEwMjRiXG4gKiB3ZSB1c2UgbWQ1IGhlcmUsIGl0IHdvcmtzIHdlbGwgb24gMWsrIGJ5dGVzLCBidXQgc3Vja3Mgd2l0aCBmZXdlciBkYXRhXG4gKiBjb3VsZCBpbXByb3ZlIHBlcmZvcm1hbmNlIHVzaW5nIGNyYzMyIGFmdGVyIGJlbmNobWFya3MuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9NRDUoZGF0YTogQnVmZmVyIHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShkYXRhKS5kaWdlc3QoJ2hleCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21IZXhTdHJpbmcobGVuZ3RoID0gOCk6IHN0cmluZyB7XG4gIHJldHVybiBwc2V1ZG9SYW5kb21CeXRlcyhsZW5ndGgpLnRvU3RyaW5nKCdoZXgnKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25QYXlsb2FkKHBheWxvYWQ6IFJlbW90ZVVzZXIsIHNlY3JldE9yUHJpdmF0ZUtleTogc3RyaW5nLCBvcHRpb25zOiBKV1RTaWduT3B0aW9ucyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gand0LnNpZ24oXG4gICAgICBwYXlsb2FkLFxuICAgICAgc2VjcmV0T3JQcml2YXRlS2V5LFxuICAgICAge1xuICAgICAgICBub3RCZWZvcmU6ICcxJywgLy8gTWFrZSBzdXJlIHRoZSB0aW1lIHdpbGwgbm90IHJvbGxiYWNrIDopXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB9LFxuICAgICAgKGVycm9yLCB0b2tlbikgPT4gKGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUodG9rZW4pKVxuICAgICk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5UGF5bG9hZCh0b2tlbjogc3RyaW5nLCBzZWNyZXRPclByaXZhdGVLZXk6IHN0cmluZyk6IFJlbW90ZVVzZXIge1xuICByZXR1cm4gand0LnZlcmlmeSh0b2tlbiwgc2VjcmV0T3JQcml2YXRlS2V5KTtcbn1cbiJdfQ==