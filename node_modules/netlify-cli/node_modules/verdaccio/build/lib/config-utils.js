"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMatchedPackagesSpec = getMatchedPackagesSpec;
exports.hasProxyTo = hasProxyTo;
exports.normalisePackageAccess = normalisePackageAccess;
exports.normalizeUserList = normalizeUserList;
exports.sanityCheckNames = sanityCheckNames;
exports.sanityCheckUplinksProps = sanityCheckUplinksProps;
exports.uplinkSanityCheck = uplinkSanityCheck;

var _assert = _interopRequireDefault(require("assert"));

var _lodash = _interopRequireDefault(require("lodash"));

var _minimatch = _interopRequireDefault(require("minimatch"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const BLACKLIST = {
  all: true,
  anonymous: true,
  undefined: true,
  owner: true,
  none: true
};
/**
 * Normalize user list.
 * @return {Array}
 */

function normalizeUserList(oldFormat, newFormat) {
  const result = [];
  /* eslint prefer-rest-params: "off" */

  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] == null) {
      continue;
    } // if it's a string, split it to array


    if (_lodash.default.isString(arguments[i])) {
      result.push(arguments[i].split(/\s+/));
    } else if (Array.isArray(arguments[i])) {
      result.push(arguments[i]);
    } else {
      throw _utils.ErrorCode.getInternalError('CONFIG: bad package acl (array or string expected): ' + JSON.stringify(arguments[i]));
    }
  }

  return _lodash.default.flatten(result);
}

function uplinkSanityCheck(uplinks, users = BLACKLIST) {
  const newUplinks = _lodash.default.clone(uplinks);

  let newUsers = _lodash.default.clone(users);

  for (const uplink in newUplinks) {
    if (Object.prototype.hasOwnProperty.call(newUplinks, uplink)) {
      if (_lodash.default.isNil(newUplinks[uplink].cache)) {
        newUplinks[uplink].cache = true;
      }

      newUsers = sanityCheckNames(uplink, newUsers);
    }
  }

  return newUplinks;
}

function sanityCheckNames(item, users) {
  (0, _assert.default)(item !== 'all' && item !== 'owner' && item !== 'anonymous' && item !== 'undefined' && item !== 'none', 'CONFIG: reserved uplink name: ' + item);
  (0, _assert.default)(!item.match(/\s/), 'CONFIG: invalid uplink name: ' + item);
  (0, _assert.default)(_lodash.default.isNil(users[item]), 'CONFIG: duplicate uplink name: ' + item);
  users[item] = true;
  return users;
}

function sanityCheckUplinksProps(configUpLinks) {
  const uplinks = _lodash.default.clone(configUpLinks);

  for (const uplink in uplinks) {
    if (Object.prototype.hasOwnProperty.call(uplinks, uplink)) {
      (0, _assert.default)(uplinks[uplink].url, 'CONFIG: no url for uplink: ' + uplink);
      (0, _assert.default)(_lodash.default.isString(uplinks[uplink].url), 'CONFIG: wrong url format for uplink: ' + uplink);
      uplinks[uplink].url = uplinks[uplink].url.replace(/\/$/, '');
    }
  }

  return uplinks;
}
/**
 * Check whether an uplink can proxy
 */


function hasProxyTo(pkg, upLink, packages) {
  const matchedPkg = getMatchedPackagesSpec(pkg, packages);
  const proxyList = typeof matchedPkg !== 'undefined' ? matchedPkg.proxy : [];

  if (proxyList) {
    return proxyList.some(curr => upLink === curr);
  }

  return false;
}

function getMatchedPackagesSpec(pkgName, packages) {
  for (const i in packages) {
    if (_minimatch.default.makeRe(i).exec(pkgName)) {
      return packages[i];
    }
  }

  return;
}

function normalisePackageAccess(packages) {
  const normalizedPkgs = _objectSpread({}, packages); // add a default rule for all packages to make writing plugins easier


  if (_lodash.default.isNil(normalizedPkgs['**'])) {
    normalizedPkgs['**'] = {
      access: [],
      publish: [],
      proxy: []
    };
  }

  for (const pkg in packages) {
    if (Object.prototype.hasOwnProperty.call(packages, pkg)) {
      (0, _assert.default)(_lodash.default.isObject(packages[pkg]) && _lodash.default.isArray(packages[pkg]) === false, `CONFIG: bad "'${pkg}'" package description (object expected)`);
      normalizedPkgs[pkg].access = normalizeUserList(packages[pkg].allow_access, packages[pkg].access);
      delete normalizedPkgs[pkg].allow_access;
      normalizedPkgs[pkg].publish = normalizeUserList(packages[pkg].allow_publish, packages[pkg].publish);
      delete normalizedPkgs[pkg].allow_publish;
      normalizedPkgs[pkg].proxy = normalizeUserList(packages[pkg].proxy_access, packages[pkg].proxy);
      delete normalizedPkgs[pkg].proxy_access; // if unpublish is not defined, we set to false to fallback in publish access

      normalizedPkgs[pkg].unpublish = _lodash.default.isUndefined(packages[pkg].unpublish) ? false : normalizeUserList([], packages[pkg].unpublish);
    }
  }

  return normalizedPkgs;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29uZmlnLXV0aWxzLnRzIl0sIm5hbWVzIjpbIkJMQUNLTElTVCIsImFsbCIsImFub255bW91cyIsInVuZGVmaW5lZCIsIm93bmVyIiwibm9uZSIsIm5vcm1hbGl6ZVVzZXJMaXN0Iiwib2xkRm9ybWF0IiwibmV3Rm9ybWF0IiwicmVzdWx0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsIl8iLCJpc1N0cmluZyIsInB1c2giLCJzcGxpdCIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yQ29kZSIsImdldEludGVybmFsRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiZmxhdHRlbiIsInVwbGlua1Nhbml0eUNoZWNrIiwidXBsaW5rcyIsInVzZXJzIiwibmV3VXBsaW5rcyIsImNsb25lIiwibmV3VXNlcnMiLCJ1cGxpbmsiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpc05pbCIsImNhY2hlIiwic2FuaXR5Q2hlY2tOYW1lcyIsIml0ZW0iLCJtYXRjaCIsInNhbml0eUNoZWNrVXBsaW5rc1Byb3BzIiwiY29uZmlnVXBMaW5rcyIsInVybCIsInJlcGxhY2UiLCJoYXNQcm94eVRvIiwicGtnIiwidXBMaW5rIiwicGFja2FnZXMiLCJtYXRjaGVkUGtnIiwiZ2V0TWF0Y2hlZFBhY2thZ2VzU3BlYyIsInByb3h5TGlzdCIsInByb3h5Iiwic29tZSIsImN1cnIiLCJwa2dOYW1lIiwibWluaW1hdGNoIiwibWFrZVJlIiwiZXhlYyIsIm5vcm1hbGlzZVBhY2thZ2VBY2Nlc3MiLCJub3JtYWxpemVkUGtncyIsImFjY2VzcyIsInB1Ymxpc2giLCJpc09iamVjdCIsImFsbG93X2FjY2VzcyIsImFsbG93X3B1Ymxpc2giLCJwcm94eV9hY2Nlc3MiLCJ1bnB1Ymxpc2giLCJpc1VuZGVmaW5lZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUlBOztBQUNBOztBQUNBOztBQUtBOzs7Ozs7Ozs7O0FBRUEsTUFB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QUEzQyxDQUE5QztBQUNBLGFBQU9ELGNBQWMsQ0FBQ2QsR0FBRCxDQUFkLENBQW9Ca0IsWUFBM0I7QUFDQUosTUFBQUEsY0FBYyxDQUFDZCxHQUFELENBQWQsQ0FBb0JnQixPQUFwQixHQUE4QnZELGlCQUFpQixDQUFDeUMsUUFBUSxDQUFDRixHQUFELENBQVIsQ0FBY21CLGFBQWYsRUFBOEJqQixRQUFRLENBQUNGLEdBQUQsQ0FBUixDQUFjZ0IsT0FBNUMsQ0FBL0M7QUFDQSxhQUFPRixjQUFjLENBQUNkLEdBQUQsQ0FBZCxDQUFvQm1CLGFBQTNCO0FBQ0FMLE1BQUFBLGNBQWMsQ0FBQ2QsR0FBRCxDQUFkLENBQW9CTSxLQUFwQixHQUE0QjdDLGlCQUFpQixDQUFDeUMsUUFBUSxDQUFDRixHQUFELENBQVIsQ0FBY29CLFlBQWYsRUFBNkJsQixRQUFRLENBQUNGLEdBQUQsQ0FBUixDQUFjTSxLQUEzQyxDQUE3QztBQUNBLGFBQU9RLGNBQWMsQ0FBQ2QsR0FBRCxDQUFkLENBQW9Cb0IsWUFBM0IsQ0FQdUQsQ0FRdkQ7O0FBQ0FOLE1BQUFBLGNBQWMsQ0FBQ2QsR0FBRCxDQUFkLENBQW9CcUIsU0FBcEIsR0FBZ0NyRCxnQkFBRXNELFdBQUYsQ0FBY3BCLFFBQVEsQ0FBQ0YsR0FBRCxDQUFSLENBQWNxQixTQUE1QixJQUF5QyxLQUF6QyxHQUFpRDVELGlCQUFpQixDQUFDLEVBQUQsRUFBS3lDLFFBQVEsQ0FBQ0YsR0FBRCxDQUFSLENBQWNxQixTQUFuQixDQUFsRztBQUNEO0FBQ0Y7O0FBRUQsU0FBT1AsY0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqIEBmbG93XG4gKi9cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbWluaW1hdGNoIGZyb20gJ21pbmltYXRjaCc7XG5cbmltcG9ydCB7IFBhY2thZ2VMaXN0LCBVcExpbmtzQ29uZkxpc3QgfSBmcm9tICdAdmVyZGFjY2lvL3R5cGVzJztcblxuaW1wb3J0IHsgTGVnYWN5UGFja2FnZUxpc3QsIE1hdGNoZWRQYWNrYWdlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgRXJyb3JDb2RlIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IEJMQUNLTElTVCA9IHtcbiAgYWxsOiB0cnVlLFxuICBhbm9ueW1vdXM6IHRydWUsXG4gIHVuZGVmaW5lZDogdHJ1ZSxcbiAgb3duZXI6IHRydWUsXG4gIG5vbmU6IHRydWUsXG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB1c2VyIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVVzZXJMaXN0KG9sZEZvcm1hdDogYW55LCBuZXdGb3JtYXQ6IGFueSk6IGFueSB7XG4gIGNvbnN0IHJlc3VsdDogYW55W11bXSA9IFtdO1xuICAvKiBlc2xpbnQgcHJlZmVyLXJlc3QtcGFyYW1zOiBcIm9mZlwiICovXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJndW1lbnRzW2ldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGl0J3MgYSBzdHJpbmcsIHNwbGl0IGl0IHRvIGFycmF5XG4gICAgaWYgKF8uaXNTdHJpbmcoYXJndW1lbnRzW2ldKSkge1xuICAgICAgcmVzdWx0LnB1c2goYXJndW1lbnRzW2ldLnNwbGl0KC9cXHMrLykpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbaV0pKSB7XG4gICAgICByZXN1bHQucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcignQ09ORklHOiBiYWQgcGFja2FnZSBhY2wgKGFycmF5IG9yIHN0cmluZyBleHBlY3RlZCk6ICcgKyBKU09OLnN0cmluZ2lmeShhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF8uZmxhdHRlbihyZXN1bHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBsaW5rU2FuaXR5Q2hlY2sodXBsaW5rczogVXBMaW5rc0NvbmZMaXN0LCB1c2VyczogYW55ID0gQkxBQ0tMSVNUKTogVXBMaW5rc0NvbmZMaXN0IHtcbiAgY29uc3QgbmV3VXBsaW5rcyA9IF8uY2xvbmUodXBsaW5rcyk7XG4gIGxldCBuZXdVc2VycyA9IF8uY2xvbmUodXNlcnMpO1xuXG4gIGZvciAoY29uc3QgdXBsaW5rIGluIG5ld1VwbGlua3MpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5ld1VwbGlua3MsIHVwbGluaykpIHtcbiAgICAgIGlmIChfLmlzTmlsKG5ld1VwbGlua3NbdXBsaW5rXS5jYWNoZSkpIHtcbiAgICAgICAgbmV3VXBsaW5rc1t1cGxpbmtdLmNhY2hlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5ld1VzZXJzID0gc2FuaXR5Q2hlY2tOYW1lcyh1cGxpbmssIG5ld1VzZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VXBsaW5rcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhbml0eUNoZWNrTmFtZXMoaXRlbTogc3RyaW5nLCB1c2VyczogYW55KTogYW55IHtcbiAgYXNzZXJ0KGl0ZW0gIT09ICdhbGwnICYmIGl0ZW0gIT09ICdvd25lcicgJiYgaXRlbSAhPT0gJ2Fub255bW91cycgJiYgaXRlbSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXRlbSAhPT0gJ25vbmUnLCAnQ09ORklHOiByZXNlcnZlZCB1cGxpbmsgbmFtZTogJyArIGl0ZW0pO1xuICBhc3NlcnQoIWl0ZW0ubWF0Y2goL1xccy8pLCAnQ09ORklHOiBpbnZhbGlkIHVwbGluayBuYW1lOiAnICsgaXRlbSk7XG4gIGFzc2VydChfLmlzTmlsKHVzZXJzW2l0ZW1dKSwgJ0NPTkZJRzogZHVwbGljYXRlIHVwbGluayBuYW1lOiAnICsgaXRlbSk7XG4gIHVzZXJzW2l0ZW1dID0gdHJ1ZTtcblxuICByZXR1cm4gdXNlcnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdHlDaGVja1VwbGlua3NQcm9wcyhjb25maWdVcExpbmtzOiBVcExpbmtzQ29uZkxpc3QpOiBVcExpbmtzQ29uZkxpc3Qge1xuICBjb25zdCB1cGxpbmtzID0gXy5jbG9uZShjb25maWdVcExpbmtzKTtcblxuICBmb3IgKGNvbnN0IHVwbGluayBpbiB1cGxpbmtzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1cGxpbmtzLCB1cGxpbmspKSB7XG4gICAgICBhc3NlcnQodXBsaW5rc1t1cGxpbmtdLnVybCwgJ0NPTkZJRzogbm8gdXJsIGZvciB1cGxpbms6ICcgKyB1cGxpbmspO1xuICAgICAgYXNzZXJ0KF8uaXNTdHJpbmcodXBsaW5rc1t1cGxpbmtdLnVybCksICdDT05GSUc6IHdyb25nIHVybCBmb3JtYXQgZm9yIHVwbGluazogJyArIHVwbGluayk7XG4gICAgICB1cGxpbmtzW3VwbGlua10udXJsID0gdXBsaW5rc1t1cGxpbmtdLnVybC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGxpbmtzO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gdXBsaW5rIGNhbiBwcm94eVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzUHJveHlUbyhwa2c6IHN0cmluZywgdXBMaW5rOiBzdHJpbmcsIHBhY2thZ2VzOiBQYWNrYWdlTGlzdCk6IGJvb2xlYW4ge1xuICBjb25zdCBtYXRjaGVkUGtnOiBNYXRjaGVkUGFja2FnZSA9IGdldE1hdGNoZWRQYWNrYWdlc1NwZWMocGtnLCBwYWNrYWdlcyk7XG4gIGNvbnN0IHByb3h5TGlzdCA9IHR5cGVvZiBtYXRjaGVkUGtnICE9PSAndW5kZWZpbmVkJyA/IG1hdGNoZWRQa2cucHJveHkgOiBbXTtcbiAgaWYgKHByb3h5TGlzdCkge1xuICAgIHJldHVybiBwcm94eUxpc3Quc29tZSgoY3VycikgPT4gdXBMaW5rID09PSBjdXJyKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hdGNoZWRQYWNrYWdlc1NwZWMocGtnTmFtZTogc3RyaW5nLCBwYWNrYWdlczogUGFja2FnZUxpc3QpOiBNYXRjaGVkUGFja2FnZSB7XG4gIGZvciAoY29uc3QgaSBpbiBwYWNrYWdlcykge1xuICAgIGlmIChtaW5pbWF0Y2gubWFrZVJlKGkpLmV4ZWMocGtnTmFtZSkpIHtcbiAgICAgIHJldHVybiBwYWNrYWdlc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXNlUGFja2FnZUFjY2VzcyhwYWNrYWdlczogTGVnYWN5UGFja2FnZUxpc3QpOiBMZWdhY3lQYWNrYWdlTGlzdCB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQa2dzOiBMZWdhY3lQYWNrYWdlTGlzdCA9IHsgLi4ucGFja2FnZXMgfTtcbiAgLy8gYWRkIGEgZGVmYXVsdCBydWxlIGZvciBhbGwgcGFja2FnZXMgdG8gbWFrZSB3cml0aW5nIHBsdWdpbnMgZWFzaWVyXG4gIGlmIChfLmlzTmlsKG5vcm1hbGl6ZWRQa2dzWycqKiddKSkge1xuICAgIG5vcm1hbGl6ZWRQa2dzWycqKiddID0geyBhY2Nlc3M6IFtdLCBwdWJsaXNoOiBbXSwgcHJveHk6IFtdIH07XG4gIH1cblxuICBmb3IgKGNvbnN0IHBrZyBpbiBwYWNrYWdlcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFja2FnZXMsIHBrZykpIHtcbiAgICAgIGFzc2VydChfLmlzT2JqZWN0KHBhY2thZ2VzW3BrZ10pICYmIF8uaXNBcnJheShwYWNrYWdlc1twa2ddKSA9PT0gZmFsc2UsIGBDT05GSUc6IGJhZCBcIicke3BrZ30nXCIgcGFja2FnZSBkZXNjcmlwdGlvbiAob2JqZWN0IGV4cGVjdGVkKWApO1xuICAgICAgbm9ybWFsaXplZFBrZ3NbcGtnXS5hY2Nlc3MgPSBub3JtYWxpemVVc2VyTGlzdChwYWNrYWdlc1twa2ddLmFsbG93X2FjY2VzcywgcGFja2FnZXNbcGtnXS5hY2Nlc3MpO1xuICAgICAgZGVsZXRlIG5vcm1hbGl6ZWRQa2dzW3BrZ10uYWxsb3dfYWNjZXNzO1xuICAgICAgbm9ybWFsaXplZFBrZ3NbcGtnXS5wdWJsaXNoID0gbm9ybWFsaXplVXNlckxpc3QocGFja2FnZXNbcGtnXS5hbGxvd19wdWJsaXNoLCBwYWNrYWdlc1twa2ddLnB1Ymxpc2gpO1xuICAgICAgZGVsZXRlIG5vcm1hbGl6ZWRQa2dzW3BrZ10uYWxsb3dfcHVibGlzaDtcbiAgICAgIG5vcm1hbGl6ZWRQa2dzW3BrZ10ucHJveHkgPSBub3JtYWxpemVVc2VyTGlzdChwYWNrYWdlc1twa2ddLnByb3h5X2FjY2VzcywgcGFja2FnZXNbcGtnXS5wcm94eSk7XG4gICAgICBkZWxldGUgbm9ybWFsaXplZFBrZ3NbcGtnXS5wcm94eV9hY2Nlc3M7XG4gICAgICAvLyBpZiB1bnB1Ymxpc2ggaXMgbm90IGRlZmluZWQsIHdlIHNldCB0byBmYWxzZSB0byBmYWxsYmFjayBpbiBwdWJsaXNoIGFjY2Vzc1xuICAgICAgbm9ybWFsaXplZFBrZ3NbcGtnXS51bnB1Ymxpc2ggPSBfLmlzVW5kZWZpbmVkKHBhY2thZ2VzW3BrZ10udW5wdWJsaXNoKSA/IGZhbHNlIDogbm9ybWFsaXplVXNlckxpc3QoW10sIHBhY2thZ2VzW3BrZ10udW5wdWJsaXNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZFBrZ3M7XG59XG4iXX0=