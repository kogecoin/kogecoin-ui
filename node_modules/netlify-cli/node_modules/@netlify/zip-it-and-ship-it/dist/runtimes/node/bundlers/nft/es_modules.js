"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transpileESM = void 0;
const path_1 = require("path");
const fs_1 = require("../../../../utils/fs");
const transpile_1 = require("./transpile");
const getPatchedESMPackages = async (packages, fsCache) => {
    const patchedPackages = await Promise.all(packages.map((path) => patchESMPackage(path, fsCache)));
    const patchedPackagesMap = new Map();
    packages.forEach((packagePath, index) => {
        patchedPackagesMap.set(packagePath, patchedPackages[index]);
    });
    return patchedPackagesMap;
};
const patchESMPackage = async (path, fsCache) => {
    const file = (await (0, fs_1.cachedReadFile)(fsCache, path, 'utf8'));
    const packageJson = JSON.parse(file);
    const patchedPackageJson = {
        ...packageJson,
        type: 'commonjs',
    };
    return JSON.stringify(patchedPackageJson);
};
const shouldTranspile = (path, cache, esmPaths, reasons) => {
    if (cache.has(path)) {
        return cache.get(path);
    }
    const reason = reasons.get(path);
    // This isn't an expected case, but if the path doesn't exist in `reasons` we
    // don't transpile it.
    if (reason === undefined) {
        cache.set(path, false);
        return false;
    }
    const { parents } = reason;
    // If the path is an entrypoint, we transpile it only if it's an ESM file.
    if (parents.size === 0) {
        const isESM = esmPaths.has(path);
        cache.set(path, isESM);
        return isESM;
    }
    // The path should be transpiled if every parent will also be transpiled, or
    // if there is no parent.
    const shouldTranspilePath = [...parents].every((parentPath) => shouldTranspile(parentPath, cache, esmPaths, reasons));
    cache.set(path, shouldTranspilePath);
    return shouldTranspilePath;
};
const transpileESM = async ({ basePath, config, esmPaths, fsCache, reasons, }) => {
    const cache = new Map();
    const pathsToTranspile = [...esmPaths].filter((path) => shouldTranspile(path, cache, esmPaths, reasons));
    const pathsToTranspileSet = new Set(pathsToTranspile);
    const packageJsonPaths = [...reasons.entries()]
        .filter(([path, reason]) => {
        if ((0, path_1.basename)(path) !== 'package.json') {
            return false;
        }
        const needsPatch = [...reason.parents].some((parentPath) => pathsToTranspileSet.has(parentPath));
        return needsPatch;
    })
        .map(([path]) => (basePath ? (0, path_1.resolve)(basePath, path) : (0, path_1.resolve)(path)));
    const rewrites = await getPatchedESMPackages(packageJsonPaths, fsCache);
    await Promise.all(pathsToTranspile.map(async (path) => {
        const absolutePath = basePath ? (0, path_1.resolve)(basePath, path) : (0, path_1.resolve)(path);
        const transpiled = await (0, transpile_1.transpile)(absolutePath, config);
        rewrites.set(absolutePath, transpiled);
    }));
    return rewrites;
};
exports.transpileESM = transpileESM;
//# sourceMappingURL=es_modules.js.map