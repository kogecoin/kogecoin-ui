"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const cp_file_1 = __importDefault(require("cp-file"));
const bundlers_1 = require("./bundlers");
const finder_1 = require("./finder");
const in_source_config_1 = require("./in_source_config");
const detect_es_module_1 = require("./utils/detect_es_module");
const plugin_modules_path_1 = require("./utils/plugin_modules_path");
const zip_1 = require("./utils/zip");
// We use ZISI as the default bundler, except for certain extensions, for which
// esbuild is the only option.
const getDefaultBundler = async ({ extension, mainFile, featureFlags, }) => {
    const { defaultEsModulesToEsbuild, traceWithNft } = featureFlags;
    if (['.mjs', '.ts'].includes(extension)) {
        return 'esbuild';
    }
    if (traceWithNft) {
        return 'nft';
    }
    if (defaultEsModulesToEsbuild) {
        const isEsModule = await (0, detect_es_module_1.detectEsModule)({ mainFile });
        if (isEsModule) {
            return 'esbuild';
        }
    }
    return 'zisi';
};
// A proxy for the `getSrcFiles` function which adds a default `bundler` using
// the `getDefaultBundler` function.
const getSrcFilesWithBundler = async (parameters) => {
    const pluginsModulesPath = await (0, plugin_modules_path_1.getPluginsModulesPath)(parameters.srcDir);
    const bundlerName = parameters.config.nodeBundler ||
        (await getDefaultBundler({
            extension: parameters.extension,
            featureFlags: parameters.featureFlags,
            mainFile: parameters.mainFile,
        }));
    const bundler = (0, bundlers_1.getBundler)(bundlerName);
    return bundler.getSrcFiles({ ...parameters, pluginsModulesPath });
};
const zipFunction = async function ({ archiveFormat, basePath, config = {}, destFolder, extension, featureFlags, filename, mainFile, name, repositoryRoot, runtime, srcDir, srcPath, stat, }) {
    const pluginsModulesPath = await (0, plugin_modules_path_1.getPluginsModulesPath)(srcDir);
    const bundlerName = config.nodeBundler || (await getDefaultBundler({ extension, mainFile, featureFlags }));
    const bundler = (0, bundlers_1.getBundler)(bundlerName);
    // If the file is a zip, we assume the function is bundled and ready to go.
    // We simply copy it to the destination path with no further processing.
    if (extension === '.zip') {
        const destPath = (0, path_1.join)(destFolder, filename);
        await (0, cp_file_1.default)(srcPath, destPath);
        return { config, path: destPath };
    }
    const { aliases = new Map(), cleanupFunction, basePath: finalBasePath, bundlerWarnings, inputs, mainFile: finalMainFile = mainFile, nativeNodeModules, nodeModulesWithDynamicImports, rewrites, srcFiles, } = await bundler.bundle({
        basePath,
        config,
        extension,
        featureFlags,
        filename,
        mainFile,
        name,
        pluginsModulesPath,
        repositoryRoot,
        runtime,
        srcDir,
        srcPath,
        stat,
    });
    const inSourceConfig = await (0, in_source_config_1.findISCDeclarationsInPath)(mainFile);
    (0, plugin_modules_path_1.createAliases)(srcFiles, pluginsModulesPath, aliases, finalBasePath);
    const zipPath = await (0, zip_1.zipNodeJs)({
        aliases,
        archiveFormat,
        basePath: finalBasePath,
        destFolder,
        extension,
        filename,
        mainFile: finalMainFile,
        rewrites,
        srcFiles,
    });
    await (cleanupFunction === null || cleanupFunction === void 0 ? void 0 : cleanupFunction());
    return {
        bundler: bundlerName,
        bundlerWarnings,
        config,
        inputs,
        inSourceConfig,
        nativeNodeModules,
        nodeModulesWithDynamicImports,
        path: zipPath,
    };
};
const zipWithFunctionWithFallback = async ({ config = {}, ...parameters }) => {
    // If a specific JS bundler version is specified, we'll use it.
    if (config.nodeBundler !== 'esbuild_zisi') {
        return zipFunction({ ...parameters, config });
    }
    // Otherwise, we'll try to bundle with esbuild and, if that fails, fallback
    // to zisi.
    try {
        return await zipFunction({ ...parameters, config: { ...config, nodeBundler: 'esbuild' } });
    }
    catch (esbuildError) {
        try {
            const data = await zipFunction({ ...parameters, config: { ...config, nodeBundler: 'zisi' } });
            return { ...data, bundlerErrors: esbuildError.errors };
        }
        catch {
            throw esbuildError;
        }
    }
};
const runtime = {
    findFunctionsInPaths: finder_1.findFunctionsInPaths,
    findFunctionInPath: finder_1.findFunctionInPath,
    getSrcFiles: getSrcFilesWithBundler,
    name: 'js',
    zipFunction: zipWithFunctionWithFallback,
};
exports.default = runtime;
//# sourceMappingURL=index.js.map