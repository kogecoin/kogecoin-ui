"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPathsOfIncludedFiles = exports.filterExcludedPaths = void 0;
const path_1 = require("path");
const util_1 = require("util");
const glob_1 = __importDefault(require("glob"));
const minimatch_1 = __importDefault(require("minimatch"));
const pGlob = (0, util_1.promisify)(glob_1.default);
// Returns the subset of `paths` that don't match any of the glob expressions
// from `exclude`.
const filterExcludedPaths = (paths, exclude = []) => {
    if (exclude.length === 0) {
        return paths;
    }
    const excludedPaths = paths.filter((path) => !exclude.some((pattern) => (0, minimatch_1.default)(path, pattern)));
    return excludedPaths;
};
exports.filterExcludedPaths = filterExcludedPaths;
const getPathsOfIncludedFiles = async (includedFiles, basePath) => {
    if (basePath === undefined) {
        return { exclude: [], paths: [] };
    }
    // Some of the globs in `includedFiles` might be exclusion patterns, which
    // means paths that should NOT be included in the bundle. We need to treat
    // these differently, so we iterate on the array and put those paths in a
    // `exclude` array and the rest of the paths in an `include` array.
    const { include, exclude } = includedFiles.reduce((acc, path) => {
        if (path.startsWith('!')) {
            const excludePath = (0, path_1.resolve)(basePath, path.slice(1));
            return {
                include: acc.include,
                exclude: [...acc.exclude, excludePath],
            };
        }
        return {
            include: [...acc.include, path],
            exclude: acc.exclude,
        };
    }, { include: [], exclude: [] });
    const pathGroups = await Promise.all(include.map((expression) => pGlob(expression, { absolute: true, cwd: basePath, ignore: exclude, nodir: true })));
    // `pathGroups` is an array containing the paths for each expression in the
    // `include` array. We flatten it into a single dimension.
    const paths = pathGroups.flat();
    const normalizedPaths = paths.map(path_1.normalize);
    return { exclude, paths: [...new Set(normalizedPaths)] };
};
exports.getPathsOfIncludedFiles = getPathsOfIncludedFiles;
//# sourceMappingURL=included_files.js.map