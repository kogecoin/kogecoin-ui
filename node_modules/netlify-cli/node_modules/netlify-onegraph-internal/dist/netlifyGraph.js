"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCustomHandlerSource = exports.generateHandlerSource = exports.extractFunctionsFromOperationDoc = exports.generateFunctionsSource = exports.generateTypeScriptDefinitions = exports.generateFragmentTypeScriptDefinition = exports.generateJavaScriptClient = exports.fragmentToParsedFragmentDefinition = exports.queryToFunctionDefinition = exports.generateSubscriptionFunction = exports.generateSubscriptionFunctionTypeDefinition = exports.defaultExampleOperationsDoc = exports.defaultNetlifyGraphConfig = exports.defaultGraphQLSchemaFilename = exports.defaultSourceOperationsFilename = void 0;
var uuid_1 = require("uuid");
var graphql_1 = require("graphql");
var internalConsole_1 = require("./internalConsole");
var graphqlHelpers_1 = require("./graphqlHelpers");
var genericExporter_1 = require("./codegen/genericExporter");
var nextjsExporter_1 = require("./codegen/nextjsExporter");
var remixExporter_1 = require("./codegen/remixExporter");
var capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
var replaceAll = function (target, search, replace) {
    var simpleString = search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return target.replace(new RegExp(simpleString, "g"), replace);
};
exports.defaultSourceOperationsFilename = "netlifyGraphOperationsLibrary.graphql";
exports.defaultGraphQLSchemaFilename = "netlifyGraphSchema.graphql";
exports.defaultNetlifyGraphConfig = {
    extension: "js",
    functionsPath: ["netlify", "functions"],
    netlifyGraphPath: ["netlify", "functions", "netlifyGraph"],
    webhookBasePath: "/.netlify/functions",
    netlifyGraphImplementationFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        "index.js",
    ],
    netlifyGraphTypeDefinitionsFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        "index.d.ts",
    ],
    graphQLOperationsSourceFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        exports.defaultSourceOperationsFilename,
    ],
    graphQLSchemaFilename: [
        "netlify",
        "functions",
        "netlifyGraph",
        exports.defaultGraphQLSchemaFilename,
    ],
    netlifyGraphRequirePath: ["./netlifyGraph"],
    framework: "custom",
    moduleType: "commonjs",
    language: "javascript",
    runtimeTargetEnv: "node",
};
exports.defaultExampleOperationsDoc = "query ExampleQuery @netlify(doc: \"An example query to start with.\") {\n  __typename\n}";
var generatedOneGraphClient = function (netlifyGraphConfig) {
    return out(netlifyGraphConfig, ["node"], "const httpFetch = (siteId, options) => {\n      var reqBody = options.body || null\n      const userHeaders = options.headers || {}\n      const headers = {\n        ...userHeaders,\n        'Content-Type': 'application/json',\n        'Content-Length': reqBody.length,\n      }\n   \n      var reqOptions = {\n        method: 'POST',\n        headers: headers,\n        timeout: 30000,\n      }\n      \n  const url = 'https://serve.onegraph.com/graphql?app_id=' + siteId\n\n  const respBody = []\n\n  return new Promise((resolve, reject) => {\n    var req = https.request(url, reqOptions, (res) => {\n      if (res.statusCoce && (res.statusCode < 200 || res.statusCode > 299)) {\n        return reject(\n          new Error(\n            \"Netlify OneGraph return non - OK HTTP status code\" + res.statusCode,\n          ),\n        )\n      }\n\n      res.on('data', (chunk) => respBody.push(chunk))\n\n      res.on('end', () => {\n        const resString = Buffer.concat(respBody).toString()\n        resolve(resString)\n      })\n    })\n\n    req.on('error', (e) => {\n      console.error('Error making request to Netlify OneGraph: ', e)\n    })\n\n    req.on('timeout', () => {\n      req.destroy()\n      reject(new Error('Request to Netlify OneGraph timed out'))\n    })\n\n    req.write(reqBody)\n    req.end()\n  })\n}}\n") + "\n" + out(netlifyGraphConfig, ["browser"], "const httpFetch = (siteId, options) => {\n  var reqBody = options.body || null\n  const userHeaders = options.headers || {}\n  const headers = {\n    ...userHeaders,\n    'Content-Type': 'application/json',\n  }\n\n  var reqOptions = {\n    method: 'POST',\n    headers: headers,\n    timeout: 30000,\n    body: reqBody\n  }\n\n  const url = 'https://serve.onegraph.com/graphql?app_id=' + siteId\n\n  return fetch(url, reqOptions).then(response => response.text());\n}") + "\n\nconst fetchOneGraph = async function fetchOneGraph(input) {\n  const accessToken = input.accessToken \n  const query = input.query\n  const operationName = input.operationName\n  const variables = input.variables\n  const options = input.options || {}\n\n  const siteId = options.siteId || process.env.SITE_ID\n\n  const payload = {\n    query: query,\n    variables: variables,\n    operationName: operationName,\n  }\n\n  const result = await httpFetch(\n    siteId,\n    {\n      method: 'POST',\n      headers: {\n        Authorization: accessToken ? \"Bearer \" + accessToken : '',\n      },\n      body: JSON.stringify(payload),\n    },\n  )\n\n  return JSON.parse(result)\n}\n";
};
var subscriptionParserReturnName = function (fn) { return fn.operationName + "Event"; };
var subscriptionParserName = function (fn) { return "parseAndVerify" + fn.operationName + "Event"; };
var subscriptionFunctionName = function (fn) { return "subscribeTo" + fn.operationName; };
var out = function (netlifyGraphConfig, envs, value) {
    if (!envs.includes(netlifyGraphConfig.runtimeTargetEnv)) {
        return "";
    }
    return value;
};
var exp = function (netlifyGraphConfig, envs, name, value) {
    if (!envs.includes(netlifyGraphConfig.runtimeTargetEnv)) {
        return "";
    }
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports." + name + " = " + value;
    }
    return "export const " + name + " = " + value;
};
var imp = function (netlifyGraphConfig, envs, name, packageName) {
    if (!envs.includes(netlifyGraphConfig.runtimeTargetEnv)) {
        return "";
    }
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "const " + name + " = require(\"" + packageName + "\")";
    }
    return "import " + name + " from \"" + packageName + "\"";
};
var generateSubscriptionFunctionTypeDefinition = function (schema, fn, fragments) {
    var fragmentDefinitions = Object.entries(fragments).reduce(function (acc, _a) {
        var _b;
        var fragmentName = _a[0], fragment = _a[1];
        return __assign(__assign({}, acc), (_b = {}, _b[fragmentName] = fragment.parsedOperation, _b));
    }, {});
    var parsingFunctionReturnSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperation)(schema, fn.parsedOperation, fragmentDefinitions);
    var variableNames = (fn.parsedOperation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(variableNames, schema, fn.parsedOperation);
    var jsDoc = replaceAll(fn.description || "", "*/", "!")
        .split("\n")
        .join("\n* ");
    return "/**\n* " + jsDoc + "\n*/\nexport function " + subscriptionFunctionName(fn) + "(\n  /**\n   * This will be available in your webhook handler as a query parameter.\n   * Use this to keep track of which subscription you're receiving\n   * events for.\n   */\n  netlifyGraphWebhookId: string,\n  variables: " + (variableSignature === "{}" ? "Record<string, never>" : variableSignature) + ",\n  accessToken?: string | null | undefined\n  ) : void\n\nexport type " + subscriptionParserReturnName(fn) + " = " + parsingFunctionReturnSignature + "\n\n/**\n * Verify the " + fn.operationName + " event body is signed securely, and then parse the result.\n */\nexport function " + subscriptionParserName(fn) + " (/** A Netlify Handler Event */ event : WebhookEvent) : null | " + subscriptionParserReturnName(fn) + "\n";
};
exports.generateSubscriptionFunctionTypeDefinition = generateSubscriptionFunctionTypeDefinition;
// TODO: Handle fragments
var generateSubscriptionFunction = function (schema, fn, fragments, netlifyGraphConfig) {
    var patchedWithWebhookUrl = (0, graphqlHelpers_1.patchSubscriptionWebhookField)({
        schema: schema,
        definition: fn.parsedOperation,
    });
    var patched = (0, graphqlHelpers_1.patchSubscriptionWebhookSecretField)({
        schema: schema,
        definition: patchedWithWebhookUrl,
    });
    // TODO: Don't allow unnamed operations as subscription
    var filename = (patched.name && patched.name.value) || "Unknown";
    var body = (0, graphql_1.print)(patched);
    var safeBody = replaceAll(body, "${", "\\${");
    return "const " + subscriptionFunctionName(fn) + " = async (\n  /**\n   * This will be available in your webhook handler as a query parameter.\n   * Use this to keep track of which subscription you're receiving\n   * events for.\n   */\n  netlifyGraphWebhookId,\n  variables,\n  rawOptions\n  ) => {\n    const options = rawOptions || {}\n    const netlifyGraphWebhookUrl = `${process.env.DEPLOY_URL}" + netlifyGraphConfig.webhookBasePath + "/" + filename + "?netlifyGraphWebhookId=${netlifyGraphWebhookId}`\n    const secret = options.secret || process.env.NETLIFY_GRAPH_WEBHOOK_SECRET\n    const fullVariables = {...variables, netlifyGraphWebhookUrl: netlifyGraphWebhookUrl, netlifyGraphWebhookSecret: { hmacSha256Key: secret }}\n\n    const subscriptionOperationDoc = `" + safeBody + "`;\n\n    const result = await fetchOneGraph({\n      query: subscriptionOperationDoc,\n      operationName: \"" + fn.operationName + "\",\n      variables: fullVariables,\n      options: Object.assign({accessToken: accessToken}, options || {}),\n  })\n}\n\nconst " + subscriptionParserName(fn) + " = (event) => {\n  if (!verifyRequestSignature({ event: event })) {\n    console.warn(\"Unable to verify signature for " + filename + "\")\n    return null\n  }\n  \n  return JSON.parse(event.body || '{}')\n}";
};
exports.generateSubscriptionFunction = generateSubscriptionFunction;
var makeFunctionName = function (kind, operationName) {
    if (kind === "query") {
        return "fetch" + capitalizeFirstLetter(operationName);
    }
    if (kind === "mutation") {
        return "execute" + capitalizeFirstLetter(operationName) + " ";
    }
    return capitalizeFirstLetter(operationName).trim();
};
var queryToFunctionDefinition = function (fullSchema, persistedQuery, enabledFragments) {
    var basicFn = {
        id: persistedQuery.id,
        operationString: persistedQuery.operationString,
        description: persistedQuery.description || "",
    };
    var body = basicFn.operationString;
    var safeBody = replaceAll(body, "${", "\\${");
    var parsed = (0, graphql_1.parse)(body);
    var operations = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });
    var fragmentDefinitions = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });
    var fragments = Object.values(enabledFragments).reduce(function (acc, def) {
        var _a;
        return (__assign(__assign({}, acc), (_a = {}, _a[def.fragmentName] = def.parsedOperation, _a)));
    }, {});
    if (!operations) {
        internalConsole_1.internalConsole.error("Operation definition is required in " + basicFn.id);
        return;
    }
    var operation = operations[0];
    if (operation.kind !== graphql_1.Kind.OPERATION_DEFINITION) {
        internalConsole_1.internalConsole.error("Definition is not an operation in " + basicFn.id);
        return;
    }
    var returnSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperation)(fullSchema, operation, fragments);
    var variableNames = (operation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(variableNames, fullSchema, operation);
    var operationName = operation.name && operation.name.value;
    if (!operationName) {
        internalConsole_1.internalConsole.error("Operation name is required in " + basicFn.operationString + "\n\tfound: " + JSON.stringify(operation.name));
        return;
    }
    var operationWithoutNetlifyDirective = __assign(__assign({}, operation), { directives: (operation.directives || []).filter(function (directive) { return directive.name.value !== "netlify"; }) });
    var fn = __assign(__assign({}, basicFn), { fnName: makeFunctionName(operation.operation, operationName), safeBody: safeBody, kind: operation.operation, variableSignature: variableSignature, returnSignature: returnSignature, operationName: operationName, parsedOperation: operation, operationStringWithoutNetlifyDirective: (0, graphql_1.print)(operationWithoutNetlifyDirective) });
    return fn;
};
exports.queryToFunctionDefinition = queryToFunctionDefinition;
var fragmentToParsedFragmentDefinition = function (fullSchema, persistedQuery) {
    var basicFn = {
        id: persistedQuery.id,
        operationString: persistedQuery.operationString,
        description: persistedQuery.description || "",
    };
    var body = basicFn.operationString;
    var safeBody = replaceAll(body, "${", "\\${");
    var parsed = (0, graphql_1.parse)(body);
    var operations = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });
    var fragmentDefinitions = parsed.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });
    var fragments = fragmentDefinitions.reduce(function (acc, def) {
        var _a;
        return (__assign(__assign({}, acc), (_a = {}, _a[def.name.value] = def, _a)));
    }, {});
    if (!operations) {
        internalConsole_1.internalConsole.error("Operation definition is required in " + basicFn.id);
        return;
    }
    var operation = fragmentDefinitions[0];
    if (operation.kind !== graphql_1.Kind.FRAGMENT_DEFINITION) {
        internalConsole_1.internalConsole.error("Definition is not an operation in " + basicFn.id);
        return;
    }
    var returnSignature = (0, graphqlHelpers_1.typeScriptSignatureForFragment)(fullSchema, operation, fragments);
    var variableNames = (operation.variableDefinitions || []).map(function (varDef) { return varDef.variable.name.value; });
    var variableSignature = (0, graphqlHelpers_1.typeScriptSignatureForOperationVariables)(variableNames, fullSchema, 
    // @ts-ignore TODO: FIX THIS!
    operation);
    var operationName = operation.name && operation.name.value;
    if (!operationName) {
        internalConsole_1.internalConsole.error("Operation name is required in " + basicFn.operationString + "\n\tfound: " + JSON.stringify(operation.name));
        return;
    }
    var operationWithoutNetlifyDirective = __assign(__assign({}, operation), { directives: (operation.directives || []).filter(function (directive) { return directive.name.value !== "netlify"; }) });
    var fn = __assign(__assign({}, basicFn), { safeBody: safeBody, kind: "fragment", returnSignature: returnSignature, fragmentName: operationName, parsedOperation: operation, operationStringWithoutNetlifyDirective: (0, graphql_1.print)(operationWithoutNetlifyDirective) });
    return fn;
};
exports.fragmentToParsedFragmentDefinition = fragmentToParsedFragmentDefinition;
var generateJavaScriptClient = function (netlifyGraphConfig, schema, operationsDoc, enabledFunctions) {
    var operationsWithoutTemplateDollar = replaceAll(operationsDoc, "${", "\\${");
    var safeOperationsDoc = replaceAll(operationsWithoutTemplateDollar, "`", "\\`");
    var functionDecls = enabledFunctions.map(function (fn) {
        if (fn.kind === "subscription") {
            var fragments = [];
            return (0, exports.generateSubscriptionFunction)(schema, fn, fragments, netlifyGraphConfig);
        }
        var dynamicFunction = exp(netlifyGraphConfig, ["browser", "node"], fn.fnName, "(\n      variables,\n      options\n      ) => {\n      return fetchOneGraph({\n        query: `" + fn.safeBody + "`,\n        variables: variables,\n        options: options || {},\n      })\n    }") + "\n";
        var staticFunction = "" + exp(netlifyGraphConfig, ["browser", "node"], fn.fnName, "(\n      variables,\n      options\n    ) => {\n      return fetchOneGraph({\n        query: operationsDoc,\n        operationName: \"" + fn.operationName + "\",\n        variables: variables,\n        options: options || {},\n      });\n    }\n");
        return fn.id ? staticFunction : dynamicFunction;
    });
    var exportedFunctionsObjectProperties = enabledFunctions
        .sort(function (a, b) {
        return a.fnName.localeCompare(b.fnName);
    })
        .map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            if (netlifyGraphConfig.runtimeTargetEnv === "node") {
                var subscriptionFnName = subscriptionFunctionName(fn);
                var parserFnName = subscriptionParserName(fn);
                var jsDoc_1 = replaceAll(fn.description || "", "*/", "")
                    .split("\n")
                    .join("\n* ");
                return "/**\n  * " + jsDoc_1 + "\n  */\n  " + subscriptionFnName + ":" + subscriptionFnName + ",\n  /**\n   * Verify the event body is signed securely, and then parse the result.\n   */\n  " + parserFnName + ": " + parserFnName;
            }
            else {
                return;
            }
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        return "/**\n  * " + jsDoc + "\n  */\n  " + fn.fnName + ": " + (netlifyGraphConfig.moduleType === "commonjs" ? "exports." : "") + fn.fnName;
    })
        .filter(Boolean)
        .join(",\n  ");
    var dummyHandler = exp(netlifyGraphConfig, ["node"], "handler", "async (event, context) => {\n      // return a 401 json response\n      return {\n        statusCode: 401,\n        body: JSON.stringify({\n          message: 'Unauthorized',\n        }),\n      }\n    }");
    var source = "// GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!\n" + imp(netlifyGraphConfig, ["node"], "https", "https") + "\n" + imp(netlifyGraphConfig, ["node"], "crypto", "crypto") + "\n\n" + exp(netlifyGraphConfig, ["node"], "verifySignature", "(input) => {\n  const secret = input.secret\n  const body = input.body\n  const signature = input.signature\n\n  if (!signature) {\n    console.error('Missing signature')\n    return false\n  }\n\n  const sig = {}\n  for (const pair of signature.split(',')) {\n    const [k, v] = pair.split('=')\n    sig[k] = v\n  }\n\n  if (!sig.t || !sig.hmac_sha256) {\n    console.error('Invalid signature header')\n    return false\n  }\n\n  const hash = crypto\n    .createHmac('sha256', secret)\n    .update(sig.t)\n    .update('.')\n    .update(body)\n    .digest('hex')\n\n  if (\n    !crypto.timingSafeEqual(\n      Buffer.from(hash, 'hex'),\n      Buffer.from(sig.hmac_sha256, 'hex')\n    )\n  ) {\n    console.error('Invalid signature')\n    return false\n  }\n\n  if (parseInt(sig.t, 10) < Date.now() / 1000 - 300 /* 5 minutes */) {\n    console.error('Request is too old')\n    return false\n  }\n\n  return true\n}") + "\n\nconst operationsDoc = `" + safeOperationsDoc + "`\n\n" + generatedOneGraphClient(netlifyGraphConfig) + "\n\n" + exp(netlifyGraphConfig, ["node"], "verifyRequestSignature", "(request) => {\n  const event = request.event\n  const secret = process.env.NETLIFY_GRAPH_WEBHOOK_SECRET\n  const signature = event.headers['x-netlify-graph-signature']\n  const body = event.body\n\n  if (!secret) {\n    console.error(\n      'NETLIFY_GRAPH_WEBHOOK_SECRET is not set, cannot verify incoming webhook request'\n    )\n    return false\n  }\n\n  return verifySignature({ secret, signature, body: body || '' })\n}") + "\n\n" + functionDecls.join("\n\n") + "\n  \n/**\n * The generated NetlifyGraph library with your operations\n */\nconst functions = {\n  " + exportedFunctionsObjectProperties + "\n}\n\n" + (netlifyGraphConfig.moduleType === "commonjs"
        ? "exports.default = functions"
        : "export default functions") + "\n\n" + dummyHandler;
    return source;
};
exports.generateJavaScriptClient = generateJavaScriptClient;
var generateFragmentTypeScriptDefinition = function (netlifyGraphConfig, schema, fragment) {
    var jsDoc = replaceAll(fragment.description || "", "*/", "")
        .split("\n")
        .join("\n* ");
    var baseName = fragment.fragmentName;
    var returnSignatureName = capitalizeFirstLetter(baseName);
    var inputSignatureName = capitalizeFirstLetter(baseName) + "Input";
    return "/**\n* " + jsDoc + "\n*/\nexport type " + returnSignatureName + " = " + fragment.returnSignature + ";\n";
};
exports.generateFragmentTypeScriptDefinition = generateFragmentTypeScriptDefinition;
var generateTypeScriptDefinitions = function (netlifyGraphConfig, schema, enabledFunctions, enabledFragments) {
    var fragmentDecls = Object.values(enabledFragments).map(function (fragment) {
        return (0, exports.generateFragmentTypeScriptDefinition)(netlifyGraphConfig, schema, fragment);
    });
    var functionDecls = enabledFunctions.map(function (fn) {
        var isSubscription = fn.kind === "subscription";
        if (isSubscription) {
            return (0, exports.generateSubscriptionFunctionTypeDefinition)(schema, fn, enabledFragments);
        }
        var jsDoc = replaceAll(fn.description || "", "*/", "")
            .split("\n")
            .join("\n* ");
        var baseName = fn.operationName;
        var returnSignatureName = capitalizeFirstLetter(baseName);
        var inputSignatureName = capitalizeFirstLetter(baseName) + "Input";
        var shouldExportInputSignature = fn.variableSignature !== "{}";
        var inputSignatureExport = shouldExportInputSignature
            ? "export type " + inputSignatureName + " = " + fn.variableSignature + ";\n"
            : "";
        return inputSignatureExport + "\nexport type " + returnSignatureName + " = " + fn.returnSignature + ";\n\n/**\n * " + jsDoc + "\n */\nexport function " + fn.fnName + "(\n  variables: " + (shouldExportInputSignature ? inputSignatureName : "Record<string, never>") + ",\n  options?: NetlifyGraphFunctionOptions\n): Promise<" + returnSignatureName + ">;";
    });
    var source = "// GENERATED VIA NETLIFY AUTOMATED DEV TOOLS, EDIT WITH CAUTION!\n\nexport type NetlifyGraphFunctionOptions = {\n  accessToken?: string;\n  siteId?: string; \n}\n\nexport type WebhookEvent = {\n  body: string;\n  headers: Record<string, string | null | undefined>;\n};\n\nexport type GraphQLError = {\n  \"path\": Array<string | number>,\n  \"message\": string,\n  \"extensions\": Record<string, unknown>\n};\n\n" + fragmentDecls.join("\n\n") + "\n\n" + functionDecls.join("\n\n") + "\n";
    return source;
};
exports.generateTypeScriptDefinitions = generateTypeScriptDefinitions;
var generateFunctionsSource = function (netlifyGraphConfig, schema, operationsDoc, queries, fragments) {
    var fragmentDefinitions = Object.entries(fragments).reduce(function (acc, _a) {
        var _b;
        var fragmentName = _a[0], fragment = _a[1];
        var parsed = (0, exports.fragmentToParsedFragmentDefinition)(schema, fragment);
        if (parsed) {
            return __assign(__assign({}, acc), (_b = {}, _b[fragmentName] = parsed, _b));
        }
        else {
            return acc;
        }
    }, {});
    var functionDefinitions = Object.values(queries)
        .map(function (query) {
        return (0, exports.queryToFunctionDefinition)(schema, query, fragmentDefinitions);
    })
        .filter(Boolean);
    var clientSource = (0, exports.generateJavaScriptClient)(netlifyGraphConfig, schema, operationsDoc, functionDefinitions);
    var typeDefinitionsSource = (0, exports.generateTypeScriptDefinitions)(netlifyGraphConfig, schema, functionDefinitions, fragmentDefinitions);
    return {
        clientSource: clientSource,
        typeDefinitionsSource: typeDefinitionsSource,
        functionDefinitions: functionDefinitions,
    };
};
exports.generateFunctionsSource = generateFunctionsSource;
var pluckDirectiveArgValue = function (directive, argName) {
    var _a;
    var targetArg = (_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find(function (arg) { return arg.name.value === argName; });
    if (!(targetArg && targetArg.value)) {
        return null;
    }
    if (targetArg.value.kind === graphql_1.Kind.STRING) {
        return targetArg.value.value;
    }
    return null;
};
/**
 * Extracts basic functions from a parsed GraphQL operations document
 * @param {DocumentNode} parsedDoc The parsed GraphQL document with @netlify directives
 * @returns {functions: Record<string, ExtractedFunction>, fragments: Record<string, ExtractedFragment>}
 */
var extractFunctionsFromOperationDoc = function (parsedDoc) {
    var functions = {};
    var fragments = {};
    parsedDoc.definitions.forEach(function (next) {
        var _a, _b, _c;
        if (next.kind !== graphql_1.Kind.OPERATION_DEFINITION &&
            next.kind !== graphql_1.Kind.FRAGMENT_DEFINITION) {
            return null;
        }
        var key = ((_a = next.name) === null || _a === void 0 ? void 0 : _a.value) || "unknown";
        var directive = (_b = next.directives) === null || _b === void 0 ? void 0 : _b.find(function (localDirective) { return localDirective.name.value === "netlify"; });
        if (!directive) {
            return null;
        }
        var docString = pluckDirectiveArgValue(directive, "doc") || "";
        var id = pluckDirectiveArgValue(directive, "id");
        if (!id) {
            id = (0, uuid_1.v4)();
        }
        var nextWithoutNetlifyDirective = __assign(__assign({}, next), { directives: (next.directives || []).filter(function (directive) { return directive.name.value !== "netlify"; }) });
        if (next.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
            (_c = next.name) === null || _c === void 0 ? void 0 : _c.value;
            var operation = {
                id: id,
                fragmentName: key,
                description: docString,
                parsedOperation: next,
                kind: "fragment",
                operationString: (0, graphql_1.print)(next),
                operationStringWithoutNetlifyDirective: (0, graphql_1.print)(nextWithoutNetlifyDirective),
            };
            fragments[id] = operation;
        }
        else if (next.kind === graphql_1.Kind.OPERATION_DEFINITION) {
            var fnName = makeFunctionName(next.operation, key);
            var operation = {
                id: id,
                operationName: key,
                description: docString,
                parsedOperation: next,
                kind: next.operation,
                operationString: (0, graphql_1.print)(next),
                operationStringWithoutNetlifyDirective: (0, graphql_1.print)(nextWithoutNetlifyDirective),
            };
            functions[id] = operation;
        }
    });
    //@ts-ignore
    return { functions: functions, fragments: fragments };
};
exports.extractFunctionsFromOperationDoc = extractFunctionsFromOperationDoc;
var frameworkGeneratorMap = {
    "Next.js": nextjsExporter_1.nextjsFunctionSnippet.generate,
    Remix: remixExporter_1.remixFunctionSnippet.generate,
    default: genericExporter_1.netlifyFunctionSnippet.generate,
};
var defaultGenerator = genericExporter_1.netlifyFunctionSnippet.generate;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
var generateHandlerSource = function (_a) {
    var handlerOptions = _a.handlerOptions, netlifyGraphConfig = _a.netlifyGraphConfig, operationId = _a.operationId, operationsDoc = _a.operationsDoc, schema = _a.schema;
    var parsedDoc = (0, graphql_1.parse)(operationsDoc);
    var operations = (0, exports.extractFunctionsFromOperationDoc)(parsedDoc);
    var fn = operations[operationId];
    if (!fn) {
        internalConsole_1.internalConsole.warn("Operation " + operationId + " not found in graphql.", Object.keys(operations));
        return;
    }
    var odl = (0, genericExporter_1.computeOperationDataList)({
        query: fn.operationString,
        variables: [],
    });
    var generate = frameworkGeneratorMap[netlifyGraphConfig.framework] || defaultGenerator;
    var exportedFiles = generate({
        netlifyGraphConfig: netlifyGraphConfig,
        operationDataList: odl.operationDataList,
        schema: schema,
        options: handlerOptions,
    }).exportedFiles;
    return { exportedFiles: exportedFiles, operation: fn.parsedOperation };
};
exports.generateHandlerSource = generateHandlerSource;
/**
 * Given a schema, GraphQL operations doc, a target operationId, and a Netlify Graph config, generates a set of handlers (and potentially components) for the correct framework.
 */
var generateCustomHandlerSource = function (_a) {
    var handlerOptions = _a.handlerOptions, netlifyGraphConfig = _a.netlifyGraphConfig, operationId = _a.operationId, operationsDoc = _a.operationsDoc, schema = _a.schema, generate = _a.generate;
    var parsedDoc = (0, graphql_1.parse)(operationsDoc);
    var operations = (0, exports.extractFunctionsFromOperationDoc)(parsedDoc);
    var fn = operations[operationId];
    if (!fn) {
        internalConsole_1.internalConsole.warn("Operation " + operationId + " not found in graphql.", Object.keys(operations));
        return;
    }
    var odl = (0, genericExporter_1.computeOperationDataList)({
        query: fn.operationString,
        variables: [],
    });
    var exportedFiles = generate({
        netlifyGraphConfig: netlifyGraphConfig,
        operationDataList: odl.operationDataList,
        schema: schema,
        options: handlerOptions,
    }).exportedFiles;
    return { exportedFiles: exportedFiles, operation: fn.parsedOperation };
};
exports.generateCustomHandlerSource = generateCustomHandlerSource;
//# sourceMappingURL=netlifyGraph.js.map