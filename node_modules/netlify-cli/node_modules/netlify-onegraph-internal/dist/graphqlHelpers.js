"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formElComponent = exports.remixFormInput = exports.formInput = exports.patchSubscriptionWebhookSecretField = exports.patchSubscriptionWebhookField = exports.typeScriptTypeNameForOperation = exports.typeScriptSignatureForFragment = exports.typeScriptDefinitionObjectForFragment = exports.typeScriptSignatureForOperation = exports.typeScriptDefinitionObjectForOperation = exports.listCount = exports.typeScriptSignatureForOperationVariables = exports.typeScriptForGraphQLType = exports.gatherVariableDefinitions = exports.gatherAllReferencedTypes = void 0;
var graphql_1 = require("graphql");
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
exports.default = capitalizeFirstLetter;
var scalarMap = {
    String: { kind: "scalar", type: "string" },
    ID: { kind: "scalar", type: "string" },
    Int: { kind: "scalar", type: "number" },
    Float: { kind: "scalar", type: "number" },
    Boolean: { kind: "scalar", type: "boolean" },
    GitHubGitObjectID: { kind: "scalar", type: "string" },
    GitHubURI: { kind: "scalar", type: "string" },
    // JSON: "JSON",
};
function gatherAllReferencedTypes(schema, query) {
    var types = new Set([]);
    var typeInfo = new graphql_1.TypeInfo(schema);
    (0, graphql_1.visit)(query, (0, graphql_1.visitWithTypeInfo)(typeInfo, {
        enter: function () {
            var fullType = typeInfo.getType();
            if (!!fullType) {
                var typ = (0, graphql_1.getNamedType)(fullType);
                if (typ)
                    types.add(typ.name.toLocaleLowerCase().replace("oneme", ""));
            }
        },
    }));
    var result = Array.from(types);
    return result;
}
exports.gatherAllReferencedTypes = gatherAllReferencedTypes;
function unwrapOutputType(outputType) {
    var unwrappedType = outputType;
    while ((0, graphql_1.isWrappingType)(unwrappedType)) {
        unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
}
function gatherVariableDefinitions(definition) {
    var _a;
    var extract = function (varDef) { return [
        varDef.variable.name.value,
        (0, graphql_1.print)(varDef.type),
    ]; };
    return (((_a = definition === null || definition === void 0 ? void 0 : definition.variableDefinitions) === null || _a === void 0 ? void 0 : _a.map(extract)) || []).sort(function (_a, _b) {
        var a = _a[0];
        var b = _b[0];
        return a.localeCompare(b);
    });
}
exports.gatherVariableDefinitions = gatherVariableDefinitions;
function typeScriptForGraphQLType(schema, gqlType) {
    var scalarMap = {
        String: "string",
        ID: "string",
        Int: "number",
        Float: "number",
        Boolean: "boolean",
        GitHubURI: "string",
        GitHubTimestamp: "string",
    };
    if ((0, graphql_1.isListType)(gqlType)) {
        var subType = typeScriptForGraphQLType(schema, gqlType.ofType);
        return "Array<" + subType + ">";
    }
    else if ((0, graphql_1.isObjectType)(gqlType) || (0, graphql_1.isInputObjectType)(gqlType)) {
        var fields = Object.values(gqlType.getFields()).map(function (field) {
            var nullable = !(0, graphql_1.isNonNullType)(field.type);
            var type = typeScriptForGraphQLType(schema, field.type);
            var description = !!field.description
                ? "/**\n  * " + field.description + "\n  */\n  "
                : "";
            return description + "\"" + field.name + "\"" + (nullable ? "?" : "") + ": " + type;
        });
        if (fields.length > 0) {
            return "{" + fields.join("; ") + "}";
        }
        else {
            return "Record<string, unknown> /* typeScriptForGraphQLType */";
        }
    }
    else if ((0, graphql_1.isWrappingType)(gqlType)) {
        return typeScriptForGraphQLType(schema, gqlType.ofType);
    }
    else if ((0, graphql_1.isEnumType)(gqlType)) {
        var values = gqlType.getValues();
        var enums = values.map(function (enumValue) { return "\"" + enumValue.value + "\""; });
        return enums.join(" | ");
    }
    else {
        var namedType = (0, graphql_1.getNamedType)(gqlType);
        var basicType = scalarMap[namedType === null || namedType === void 0 ? void 0 : namedType.name] || "unknown";
        return basicType;
    }
}
exports.typeScriptForGraphQLType = typeScriptForGraphQLType;
function typeScriptSignatureForOperationVariables(variableNames, schema, operationDefinition) {
    var helper = function (variableDefinition) {
        var variableName = variableDefinition.variable.name.value;
        var result = [
            variableName,
            variableDefinition,
        ];
        return result;
    };
    var variables = (operationDefinition.variableDefinitions || [])
        .map(helper)
        .filter(function (_a) {
        var variableName = _a[0];
        return variableNames.includes(variableName);
    });
    var typesObject = variables.map(function (_a) {
        var varName = _a[0], varDef = _a[1];
        var printedType = (0, graphql_1.print)(varDef.type);
        var parsedType = (0, graphql_1.parseType)(printedType);
        //@ts-ignore
        var gqlType = (0, graphql_1.typeFromAST)(schema, parsedType);
        //@ts-ignore
        var tsType = typeScriptForGraphQLType(schema, gqlType);
        return [varName, tsType];
    });
    var typeFields = typesObject
        .map(function (_a) {
        var name = _a[0], tsType = _a[1];
        return "\"" + name + "\": " + tsType;
    })
        .join("; ");
    var types = "{" + typeFields + "}";
    return types === "" ? "null" : types;
}
exports.typeScriptSignatureForOperationVariables = typeScriptSignatureForOperationVariables;
//@ts-ignore
function listCount(gqlType) {
    var inspectedType = gqlType;
    var listCount = 0;
    var totalCount = 0;
    while ((0, graphql_1.isWrappingType)(inspectedType)) {
        if ((0, graphql_1.isListType)(inspectedType)) {
            listCount = listCount + 1;
        }
        totalCount = totalCount + 1;
        if (totalCount > 30) {
            console.warn("Bailing on potential infinite recursion");
            return -99;
        }
        inspectedType = inspectedType.ofType;
    }
    return listCount;
}
exports.listCount = listCount;
var unknownScalar = { kind: "scalar", type: "unknown" };
function typeScriptDefinitionObjectForOperation(schema, operationDefinition, fragmentDefinitions, shouldLog) {
    if (shouldLog === void 0) { shouldLog = true; }
    var dummyOut = {
        kind: "object",
        namedFragments: [],
        inlineFragments: [],
        selections: {
            data: {
                kind: "selection_field",
                name: "data",
                description: "Any data retrieved by the function will be returned here [Placeholder]",
                type: {
                    kind: "scalar",
                    type: "Record<string, unknown>",
                },
            },
            errors: {
                kind: "selection_field",
                name: "errors",
                description: "Any errors in the function will be returned here [Placeholder]",
                type: {
                    kind: "array",
                    type: {
                        kind: "scalar",
                        type: "GraphQLError",
                    },
                },
            },
        },
    };
    var objectHelper = function (type, selectionSet) {
        var inlineFragments = [];
        var namedFragments = [];
        var selections = {};
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (selection.kind === graphql_1.Kind.FRAGMENT_SPREAD) {
                var fragmentName = selection.name.value;
                var definedFragment = fragmentDefinitions[fragmentName];
                if (definedFragment) {
                    namedFragments.push(fragmentName);
                }
            }
            else if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {
                var typeCondition = selection.typeCondition;
                if (!typeCondition) {
                    return;
                }
                var typeConditionName = typeCondition.name.value;
                var fragmentGqlType = (0, graphql_1.typeFromAST)(schema, typeCondition);
                if (!fragmentGqlType || !(0, graphql_1.isObjectType)(fragmentGqlType)) {
                    return;
                }
                var fragmentSelectionAsObject = objectHelper(fragmentGqlType, selection.selectionSet);
                if (!fragmentSelectionAsObject) {
                    return;
                }
                var fragmentSelections = fragmentSelectionAsObject.selections;
                var inlineFragment = {
                    kind: "inlineFragment",
                    typeCondition: typeConditionName,
                    selections: fragmentSelections,
                };
                inlineFragments.push(inlineFragment);
            }
            else if (selection.kind === graphql_1.Kind.FIELD) {
                var parentNamedType = (0, graphql_1.getNamedType)(type);
                var alias = (_a = selection.alias) === null || _a === void 0 ? void 0 : _a.value;
                var name_1 = selection.name.value;
                var displayedName = alias || name_1;
                if (name_1.startsWith("__")) {
                    return {
                        kind: "object",
                        namedFragments: [],
                        inlineFragments: [],
                        selections: {
                            displayedName: {
                                kind: "scalar",
                                description: "Internal GraphQL field",
                                type: "unknown",
                            },
                        },
                    };
                }
                var field = ((0, graphql_1.isObjectType)(parentNamedType) || (0, graphql_1.isInterfaceType)(parentNamedType)) &&
                    parentNamedType.getFields()[name_1];
                if (!field) {
                    console.warn("Could not find field", name_1, "in", 
                    // @ts-ignore
                    Object.keys(parentNamedType.getFields()));
                    return;
                }
                var gqlType = field.type;
                var namedType = (0, graphql_1.getNamedType)(gqlType);
                var subSelectionSet = selection.selectionSet;
                if ((0, graphql_1.isWrappingType)(gqlType)) {
                    var value = helper(gqlType, subSelectionSet || {
                        kind: graphql_1.Kind.SELECTION_SET,
                        selections: [],
                    });
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            description: field.description,
                            type: value,
                        };
                    }
                }
                else if ((0, graphql_1.isScalarType)(namedType)) {
                    var scalar = scalarHelper(namedType);
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        description: field.description,
                        type: scalar,
                    };
                }
                else if ((0, graphql_1.isEnumType)(namedType)) {
                    var dummySelectionSet = {
                        kind: graphql_1.Kind.SELECTION_SET,
                        selections: [],
                    };
                    var value = helper(gqlType, dummySelectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            description: field.description,
                            type: value,
                        };
                    }
                }
                else if (subSelectionSet) {
                    var value = helper(gqlType, selection.selectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            description: field.description,
                            type: value,
                        };
                    }
                }
            }
            else {
                console.warn("objectHelper got a non-field selection", selection);
            }
        });
        var final = {
            kind: "object",
            namedFragments: namedFragments,
            inlineFragments: inlineFragments,
            selections: selections,
        };
        return final;
    };
    var arrayHelper = function (type, selectionSet) {
        var parentType = (0, graphql_1.isListType)(type) && type.ofType;
        if (!parentType) {
            return;
        }
        var subType = helper(parentType, selectionSet);
        if (!subType) {
            return;
        }
        var final = {
            kind: "array",
            type: subType,
        };
        return final;
    };
    var scalarHelper = function (parentGqlType) {
        var scalarType = parentGqlType;
        var scalarName = scalarType.name;
        var scalar = scalarMap[scalarName];
        if (!scalar) {
            scalar = unknownScalar;
        }
        return scalar;
    };
    var helper = function (parentGqlType, selectionSet) {
        if ((0, graphql_1.isListType)(parentGqlType)) {
            return arrayHelper(parentGqlType, selectionSet);
        }
        else if ((0, graphql_1.isWrappingType)(parentGqlType) && (0, graphql_1.isNonNullType)(parentGqlType)) {
            return helper(parentGqlType.ofType, selectionSet);
        }
        else if ((0, graphql_1.isObjectType)(parentGqlType)) {
            return objectHelper(parentGqlType, selectionSet);
        }
        else if ((0, graphql_1.isInterfaceType)(parentGqlType)) {
            return objectHelper(parentGqlType, selectionSet);
        }
        else if ((0, graphql_1.isScalarType)(parentGqlType)) {
            return scalarHelper(parentGqlType);
        }
        else if ((0, graphql_1.isEnumType)(parentGqlType)) {
            var values = parentGqlType
                .getValues()
                .map(function (enumValue) { return "\"" + enumValue.value + "\""; });
            var outEnum = {
                kind: "enum",
                values: values,
            };
            return outEnum;
        }
        else {
            console.warn("Unrecognized type in operation", parentGqlType);
        }
    };
    var baseGqlType = (operationDefinition.kind === graphql_1.Kind.OPERATION_DEFINITION
        ? operationDefinition.operation === "query"
            ? schema.getQueryType()
            : operationDefinition.operation === "mutation"
                ? schema.getMutationType()
                : operationDefinition.operation === "subscription"
                    ? schema.getSubscriptionType()
                    : null
        : operationDefinition.kind === graphql_1.Kind.FRAGMENT_DEFINITION
            ? schema.getType(operationDefinition.typeCondition.name.value)
            : null);
    var selections = operationDefinition.selectionSet;
    var sub;
    if (baseGqlType) {
        sub = helper(baseGqlType, selections);
    }
    else {
        return dummyOut;
    }
    if (sub && sub.kind === "object") {
        var result = {
            kind: "object",
            namedFragments: [],
            inlineFragments: [],
            selections: {
                data: {
                    kind: "selection_field",
                    name: "data",
                    description: "Any data from the function will be returned here",
                    type: sub,
                },
                errors: {
                    kind: "selection_field",
                    name: "errors",
                    description: "Any errors from the function will be returned here",
                    type: {
                        kind: "array",
                        type: {
                            kind: "scalar",
                            type: "GraphQLError",
                        },
                    },
                },
            },
        };
        return result;
    }
    else {
        return dummyOut;
    }
}
exports.typeScriptDefinitionObjectForOperation = typeScriptDefinitionObjectForOperation;
var printObject = function (obj) {
    var fieldSelections = obj.selections;
    var fieldSelectionCount = Object.keys(obj.selections).length;
    var fields = Object.values(fieldSelections)
        .map(function (fieldSelection) {
        var fields = printOut(fieldSelection.type);
        var value = fields;
        var description = !!fieldSelection.description
            ? "/**\n  * " + fieldSelection.description + "\n  */\n"
            : "";
        return "" + description + fieldSelection.name + ": " + value + ";";
    })
        .join("\n  ");
    var value;
    if (fieldSelectionCount === 0 &&
        obj.namedFragments.length === 0 &&
        obj.inlineFragments.length === 0) {
        value =
            "/** No fields, named fragments, or inline fragments found */ Record<string, unknown>";
    }
    else if (obj.namedFragments.length === 0 &&
        obj.inlineFragments.length === 0) {
        value = "{\n  " + fields + "\n}";
    }
    else if (fieldSelectionCount === 0) {
        console.debug("No fields, joining named fragments", obj);
        value = obj.namedFragments.join(" & ");
    }
    else {
        console.debug("Fields and named fragments", obj);
        var subFields = fieldSelectionCount > 0
            ? "& {\n  " + fields + "\n}"
            : "";
        value = obj.namedFragments.join(" & ") + " " + subFields;
    }
    return value;
};
var printArray = function (out) {
    var value = printOut(out.type);
    return "Array<" + value + ">";
};
var printOut = function (out) {
    if (out.kind === "scalar") {
        return out.type;
    }
    else if (out.kind === "object") {
        return printObject(out);
    }
    else if (out.kind === "array") {
        return printArray(out);
    }
    else if (out.kind === "enum") {
        return out.values.join(" | ");
    }
    return "whoops";
};
function typeScriptSignatureForOperation(schema, operationDefinition, fragmentDefinitions) {
    var typeMap = typeScriptDefinitionObjectForOperation(schema, operationDefinition, fragmentDefinitions);
    var typeScript = printObject(typeMap);
    return typeScript;
}
exports.typeScriptSignatureForOperation = typeScriptSignatureForOperation;
function typeScriptDefinitionObjectForFragment(schema, fragmentDefinition, fragmentDefinitions, shouldLog) {
    if (shouldLog === void 0) { shouldLog = true; }
    var dummyOut = {
        kind: "scalar",
        type: "Record<string, unknown>",
        description: "Fragment data unavailable when generating types",
    };
    var objectHelper = function (type, selectionSet) {
        var inlineFragments = [];
        var namedFragments = [];
        var selections = {};
        selectionSet.selections.forEach(function (selection) {
            var _a;
            if (selection.kind === graphql_1.Kind.FRAGMENT_SPREAD) {
                var fragmentName = selection.name.value;
                var definedFragment = fragmentDefinitions[fragmentName];
                if (definedFragment) {
                    namedFragments.push(fragmentName);
                }
            }
            else if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {
                var typeCondition = selection.typeCondition;
                if (!typeCondition) {
                    return;
                }
                var typeConditionName = typeCondition.name.value;
                var fragmentGqlType = (0, graphql_1.typeFromAST)(schema, typeCondition);
                if (!fragmentGqlType || !(0, graphql_1.isObjectType)(fragmentGqlType)) {
                    return;
                }
                var fragmentSelectionAsObject = objectHelper(fragmentGqlType, selection.selectionSet);
                if (!fragmentSelectionAsObject) {
                    return;
                }
                var fragmentSelections = fragmentSelectionAsObject.selections;
                var inlineFragment = {
                    kind: "inlineFragment",
                    typeCondition: typeConditionName,
                    selections: fragmentSelections,
                };
                inlineFragments.push(inlineFragment);
            }
            else if (selection.kind === graphql_1.Kind.FIELD) {
                var parentNamedType = (0, graphql_1.getNamedType)(type);
                var alias = (_a = selection.alias) === null || _a === void 0 ? void 0 : _a.value;
                var name_2 = selection.name.value;
                var displayedName = alias || name_2;
                var field = ((0, graphql_1.isObjectType)(parentNamedType) || (0, graphql_1.isInterfaceType)(parentNamedType)) &&
                    parentNamedType.getFields()[name_2];
                if (!field) {
                    console.warn("Could not find field", name_2, "in", 
                    // @ts-ignore
                    Object.keys(parentNamedType.getFields()));
                    return;
                }
                if (name_2.startsWith("__")) {
                    return {
                        kind: "object",
                        namedFragments: [],
                        inlineFragments: [],
                        selections: {
                            displayedName: {
                                kind: "scalar",
                                description: "Internal GraphQL field",
                                type: "unknown",
                            },
                        },
                    };
                }
                var gqlType = field.type;
                var namedType = (0, graphql_1.getNamedType)(gqlType);
                var subSelectionSet = selection.selectionSet;
                if ((0, graphql_1.isWrappingType)(gqlType)) {
                    var value = helper(gqlType, subSelectionSet || {
                        kind: graphql_1.Kind.SELECTION_SET,
                        selections: [],
                    });
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            description: field.description,
                        };
                    }
                }
                else if ((0, graphql_1.isScalarType)(namedType)) {
                    var scalar = scalarHelper(namedType);
                    selections[displayedName] = {
                        kind: "selection_field",
                        name: displayedName,
                        type: scalar,
                        description: field.description,
                    };
                }
                else if ((0, graphql_1.isEnumType)(namedType)) {
                    var dummySelectionSet = {
                        kind: graphql_1.Kind.SELECTION_SET,
                        selections: [],
                    };
                    var value = helper(gqlType, dummySelectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            description: field.description,
                        };
                    }
                }
                else if (subSelectionSet) {
                    var value = helper(gqlType, selection.selectionSet);
                    if (value) {
                        selections[displayedName] = {
                            kind: "selection_field",
                            name: displayedName,
                            type: value,
                            description: field.description,
                        };
                    }
                }
            }
            else {
                console.warn("objectHelper got a non-field selection", selection);
            }
        });
        var final = {
            kind: "object",
            namedFragments: namedFragments,
            inlineFragments: inlineFragments,
            selections: selections,
        };
        return final;
    };
    var arrayHelper = function (type, selectionSet) {
        var parentType = (0, graphql_1.isListType)(type) && type.ofType;
        if (!parentType) {
            return;
        }
        var subType = helper(parentType, selectionSet);
        if (!subType) {
            return;
        }
        var final = {
            kind: "array",
            type: subType,
        };
        return final;
    };
    var scalarHelper = function (parentGqlType) {
        var scalarType = parentGqlType;
        var scalarName = scalarType.name;
        var scalar = scalarMap[scalarName];
        if (!scalar) {
            scalar = unknownScalar;
        }
        return scalar;
    };
    var helper = function (parentGqlType, selectionSet) {
        if ((0, graphql_1.isListType)(parentGqlType)) {
            return arrayHelper(parentGqlType, selectionSet);
        }
        else if ((0, graphql_1.isWrappingType)(parentGqlType) && (0, graphql_1.isNonNullType)(parentGqlType)) {
            return helper(parentGqlType.ofType, selectionSet);
        }
        else if ((0, graphql_1.isObjectType)(parentGqlType)) {
            return objectHelper(parentGqlType, selectionSet);
        }
        else if ((0, graphql_1.isInterfaceType)(parentGqlType)) {
            return objectHelper(parentGqlType, selectionSet);
        }
        else if ((0, graphql_1.isScalarType)(parentGqlType)) {
            return scalarHelper(parentGqlType);
        }
        else if ((0, graphql_1.isEnumType)(parentGqlType)) {
            var values = parentGqlType
                .getValues()
                .map(function (enumValue) { return "\"" + enumValue.value + "\""; });
            var outEnum = {
                kind: "enum",
                values: values,
            };
            return outEnum;
        }
        else {
            console.warn("Unrecognized type in fragment", parentGqlType);
        }
    };
    var baseGqlType = schema.getType(fragmentDefinition.typeCondition.name.value);
    var selections = fragmentDefinition.selectionSet;
    var sub;
    if (baseGqlType) {
        sub = helper(baseGqlType, selections);
    }
    else {
        return dummyOut;
    }
    if (sub && sub.kind === "object") {
        var result = sub;
        return result;
    }
    else {
        return dummyOut;
    }
}
exports.typeScriptDefinitionObjectForFragment = typeScriptDefinitionObjectForFragment;
function typeScriptSignatureForFragment(schema, fragmentDefinition, fragmentDefinitions) {
    var typeMap = typeScriptDefinitionObjectForFragment(schema, fragmentDefinition, fragmentDefinitions);
    var typeScript = printOut(typeMap);
    return typeScript;
}
exports.typeScriptSignatureForFragment = typeScriptSignatureForFragment;
function typeScriptTypeNameForOperation(name) {
    return capitalizeFirstLetter(name) + "Payload";
}
exports.typeScriptTypeNameForOperation = typeScriptTypeNameForOperation;
/**
 * Doesn't patch e.g. fragments
 */
function patchSubscriptionWebhookField(_a) {
    var _b;
    var schema = _a.schema, definition = _a.definition;
    if (definition.operation !== "subscription") {
        return definition;
    }
    var subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
        return definition;
    }
    var newSelections = definition.selectionSet.selections.map(function (selection) {
        var _a;
        if (selection.kind !== "Field")
            return selection;
        var field = subscriptionType.getFields()[selection.name.value];
        if (!field) {
            return selection;
        }
        var fieldHasWebhookUrlArg = field.args.some(function (arg) { return arg.name === "webhookUrl"; });
        var selectionHasWebhookUrlArg = (_a = selection.arguments) === null || _a === void 0 ? void 0 : _a.some(function (arg) { return arg.name.value === "webhookUrl"; });
        if (fieldHasWebhookUrlArg && !selectionHasWebhookUrlArg) {
            return __assign(__assign({}, selection), { arguments: __spreadArray(__spreadArray([], (selection.arguments || []), true), [
                    {
                        kind: "Argument",
                        name: {
                            kind: "Name",
                            value: "webhookUrl",
                        },
                        value: {
                            kind: "Variable",
                            name: {
                                kind: "Name",
                                value: "netlifyGraphWebhookUrl",
                            },
                        },
                    },
                ], false) });
        }
        return selection;
    });
    var hasWebhookVariableDefinition = (_b = definition.variableDefinitions) === null || _b === void 0 ? void 0 : _b.find(function (varDef) { return varDef.variable.name.value === "netlifyGraphWebhookUrl"; });
    var variableDefinitions = !!hasWebhookVariableDefinition
        ? definition.variableDefinitions
        : __spreadArray(__spreadArray([], (definition.variableDefinitions || []), true), [
            {
                kind: "VariableDefinition",
                type: {
                    kind: "NonNullType",
                    type: {
                        kind: "NamedType",
                        name: {
                            kind: "Name",
                            value: "String",
                        },
                    },
                },
                variable: {
                    kind: "Variable",
                    name: {
                        kind: "Name",
                        value: "netlifyGraphWebhookUrl",
                    },
                },
            },
        ], false);
    return __assign(__assign({}, definition), { 
        //@ts-ignore: Handle edge cases later
        variableDefinitions: variableDefinitions, 
        //@ts-ignore: Handle edge cases later
        selectionSet: __assign(__assign({}, definition.selectionSet), { selections: newSelections }) });
}
exports.patchSubscriptionWebhookField = patchSubscriptionWebhookField;
function patchSubscriptionWebhookSecretField(_a) {
    var _b;
    var schema = _a.schema, definition = _a.definition;
    if (definition.operation !== "subscription") {
        return definition;
    }
    var subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
        return definition;
    }
    var newSelections = definition.selectionSet.selections.map(function (selection) {
        var _a;
        if (selection.kind !== "Field")
            return selection;
        var field = subscriptionType.getFields()[selection.name.value];
        if (!field) {
            return selection;
        }
        var fieldHasWebhookSecretArg = field.args.some(function (arg) { return arg.name === "secret"; });
        var selectionHasWebhookSecretArg = (_a = selection.arguments) === null || _a === void 0 ? void 0 : _a.some(function (arg) { return arg.name.value === "secret"; });
        if (fieldHasWebhookSecretArg && !selectionHasWebhookSecretArg) {
            return __assign(__assign({}, selection), { arguments: __spreadArray(__spreadArray([], (selection.arguments || []), true), [
                    {
                        kind: "Argument",
                        name: {
                            kind: "Name",
                            value: "secret",
                        },
                        value: {
                            kind: "Variable",
                            name: {
                                kind: "Name",
                                value: "netlifyGraphWebhookSecret",
                            },
                        },
                    },
                ], false) });
        }
        return selection;
    });
    var hasWebhookVariableDefinition = (_b = definition.variableDefinitions) === null || _b === void 0 ? void 0 : _b.find(function (varDef) { return varDef.variable.name.value === "netlifyGraphWebhookSecret"; });
    var variableDefinitions = !!hasWebhookVariableDefinition
        ? definition.variableDefinitions
        : __spreadArray(__spreadArray([], (definition.variableDefinitions || []), true), [
            {
                kind: "VariableDefinition",
                type: {
                    kind: "NonNullType",
                    type: {
                        kind: "NamedType",
                        name: {
                            kind: "Name",
                            value: "OneGraphSubscriptionSecretInput",
                        },
                    },
                },
                variable: {
                    kind: "Variable",
                    name: {
                        kind: "Name",
                        value: "netlifyGraphWebhookSecret",
                    },
                },
            },
        ], false);
    return __assign(__assign({}, definition), { 
        //@ts-ignore: Handle edge cases later
        variableDefinitions: variableDefinitions, 
        //@ts-ignore: Handle edge cases later
        selectionSet: __assign(__assign({}, definition.selectionSet), { selections: newSelections }) });
}
exports.patchSubscriptionWebhookSecretField = patchSubscriptionWebhookSecretField;
var addLeftWhitespace = function (string, padding) {
    var paddingString = " ".repeat(padding);
    return string
        .split("\n")
        .map(function (line) { return paddingString + line; })
        .join("\n");
};
var formInput = function (schema, def, path) {
    if (path === void 0) { path = []; }
    var name = def.variable.name.value;
    function helper(path, type, subfield) {
        var isList = (0, graphql_1.isListType)(type);
        var namedType = (0, graphql_1.getNamedType)(type);
        var isEnum = (0, graphql_1.isEnumType)(namedType);
        var isObject = (0, graphql_1.isInputObjectType)(namedType);
        var isScalar = (0, graphql_1.isScalarType)(namedType);
        var subfieldName = subfield && subfield.name;
        var subDataEl;
        if (isList) {
            return helper(__spreadArray(__spreadArray([], path, true), [0], false), namedType, undefined);
        }
        else if (isObject) {
            // $FlowFixMe: we check this with `isObject` already
            var subFields_1 = namedType.getFields();
            if (!subFields_1) {
                return "MISSING_SUBFIELDS";
            }
            var subFieldEls = Object.keys(subFields_1)
                .map(function (fieldName) {
                var currentField = subFields_1[fieldName];
                var subPath = __spreadArray(__spreadArray([], path, true), [fieldName], false);
                var currentFieldInput = helper(subPath, currentField.type, currentField);
                return currentFieldInput;
            })
                .join("\n");
            return "<label>" + def.variable.name.value + "</label>\n  <fieldset>\n  " + addLeftWhitespace(subFieldEls, 2) + "\n  </fieldset>";
        }
        else if (isScalar) {
            var coerceFn = void 0;
            var inputAttrs = void 0;
            // $FlowFixMe: we check this with `isScalar` already
            switch (namedType.name) {
                case "String":
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
                case "Float":
                    coerceFn =
                        "(value) => try {return parseFloat(value)} catch (e) { return 0.0 }";
                    inputAttrs = [
                        ["type", "number"],
                        ["step", "0.1"],
                    ];
                    break;
                case "Int":
                    coerceFn =
                        "(value) => {try {return parseInt(value, 10)} catch (e) { return 0 }}";
                    inputAttrs = [["type", "number"]];
                    break;
                case "Boolean":
                    coerceFn = '(value) => value === "true"';
                    inputAttrs = [["type", "text"]];
                    break;
                default:
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
            }
            var updateFunction = "updateFormVariables(setFormVariables, " + JSON.stringify(path) + ", " + coerceFn + ")";
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + (subfieldName || def.variable.name.value) + "</label><input id=\"" + path.join("-") + "\" " + inputAttrs
                .map(function (_a) {
                var key = _a[0], value = _a[1];
                return key + "=\"" + value + "\"";
            })
                .join(" ") + " onChange={" + updateFunction + "} />";
        }
        else if (isEnum) {
            var updateFunction = "updateFormVariables(setFormVariables, " + JSON.stringify(path) + ", (value) => value)";
            var selectOptions = namedType
                // $FlowFixMe: we check this with `isEnum` already
                .getValues()
                .map(function (gqlEnum) {
                var enumValue = gqlEnum.value;
                var enumDescription = !!gqlEnum.description
                    ? ": " + gqlEnum.description
                    : "";
                return "<option value=\"" + enumValue + "\">" + gqlEnum.name + enumDescription + "</option>";
            })
                .join(" ");
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + def.variable.name.value + "</label><select id=\"" + path.join("-") + "\" onChange={" + updateFunction + "}> " + selectOptions + " </select>";
        }
        else {
            return "UNKNOWN_GRAPHQL_TYPE_FOR_INPUT";
        }
        return subDataEl;
    }
    var hydratedType = (0, graphql_1.typeFromAST)(schema, def.type);
    if (!hydratedType) {
        console.warn("\tCould not hydrate type for ", def.type);
        return null;
    }
    // const required = isNonNullType(hydratedType);
    var formEl = helper([name], hydratedType, undefined);
    return "" + formEl;
};
exports.formInput = formInput;
var remixFormInput = function (schema, def, path) {
    if (path === void 0) { path = []; }
    var name = def.variable.name.value;
    function helper(path, type, subfield) {
        var isList = (0, graphql_1.isListType)(type);
        var namedType = (0, graphql_1.getNamedType)(type);
        var isEnum = (0, graphql_1.isEnumType)(namedType);
        var isObject = (0, graphql_1.isInputObjectType)(namedType);
        var isScalar = (0, graphql_1.isScalarType)(namedType);
        var subfieldName = subfield && subfield.name;
        var subDataEl;
        if (isList) {
            return helper(__spreadArray(__spreadArray([], path, true), [0], false), namedType, undefined);
        }
        else if (isObject) {
            // $FlowFixMe: we check this with `isObject` already
            var subFields_2 = namedType.getFields();
            if (!subFields_2) {
                return "MISSING_SUBFIELDS";
            }
            var subFieldEls = Object.keys(subFields_2)
                .map(function (fieldName) {
                var currentField = subFields_2[fieldName];
                var subPath = __spreadArray(__spreadArray([], path, true), [fieldName], false);
                var currentFieldInput = helper(subPath, currentField.type, currentField);
                return currentFieldInput;
            })
                .join("\n");
            return "<label>" + def.variable.name.value + "</label>\n  <fieldset>\n  " + addLeftWhitespace(subFieldEls, 2) + "\n  </fieldset>";
        }
        else if (isScalar) {
            var coerceFn = void 0;
            var inputAttrs = void 0;
            switch (namedType.name) {
                case "String":
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
                case "Float":
                    coerceFn =
                        "(value) => try {return parseFloat(value)} catch (e) { return 0.0 }";
                    inputAttrs = [
                        ["type", "number"],
                        ["step", "0.1"],
                    ];
                    break;
                case "Int":
                    coerceFn =
                        "(value) => {try {return parseInt(value, 10)} catch (e) { return 0 }}";
                    inputAttrs = [["type", "number"]];
                    break;
                case "Boolean":
                    coerceFn = '(value) => value === "true"';
                    inputAttrs = [["type", "text"]];
                    break;
                default:
                    coerceFn = "(value) => value";
                    inputAttrs = [["type", "text"]];
                    break;
            }
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + (subfieldName || def.variable.name.value) + "</label><input id=\"" + path.join("-") + "\" name=\"" + path.join("-") + "\" " + inputAttrs
                .map(function (_a) {
                var key = _a[0], value = _a[1];
                return key + "=\"" + value + "\"";
            })
                .join(" ") + " />";
        }
        else if (isEnum) {
            var selectOptions = namedType
                .getValues()
                .map(function (gqlEnum) {
                var enumValue = gqlEnum.value;
                var enumDescription = !!gqlEnum.description
                    ? ": " + gqlEnum.description
                    : "";
                return "<option value=\"" + enumValue + "\">" + gqlEnum.name + enumDescription + "</option>";
            })
                .join(" ");
            subDataEl = "<label htmlFor=\"" + path.join("-") + "\">" + def.variable.name.value + "</label><select id=\"" + path.join("-") + "\" name=\"" + path.join("-") + "\"> " + selectOptions + " </select>";
        }
        else {
            return "UNKNOWN_GRAPHQL_TYPE_FOR_INPUT";
        }
        return subDataEl;
    }
    var hydratedType = (0, graphql_1.typeFromAST)(schema, def.type);
    if (!hydratedType) {
        console.warn("\tCould not hydrate type for ", def.type);
        return null;
    }
    // const required = isNonNullType(hydratedType);
    var formEl = helper([name], hydratedType, undefined);
    return "" + formEl;
};
exports.remixFormInput = remixFormInput;
var formElComponent = function (_a) {
    var operationData = _a.operationData, schema = _a.schema, callFn = _a.callFn;
    if (!schema) {
        return {
            formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
            formEl: "<pre>You must pass in a schema to generate forms for your GraphQL operation</pre>",
        };
    }
    var els = (operationData.operationDefinition.variableDefinitions || []).map(function (def) {
        var genInput = (0, exports.formInput)(schema, def, []);
        var input = genInput || "UNABLE_TO_GENERATE_FORM_INPUT_FOR_GRAPHQL_TYPE(" + def + ")";
        return "" + input;
    });
    return {
        formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
        formEl: "<form onSubmit={event => { event.preventDefault(); " + callFn + " }}>\n  " + addLeftWhitespace(els.join("\n"), 2) + "\n    <input type=\"submit\" />\n  </form>",
    };
};
exports.formElComponent = formElComponent;
//# sourceMappingURL=graphqlHelpers.js.map