export declare const internalOperationsDoc = "\nmutation CreatePersistedQueryMutation(\n  $nfToken: String!\n  $appId: String!\n  $query: String!\n  $tags: [String!]!\n  $description: String!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    createPersistedQuery(\n      input: {\n        query: $query\n        appId: $appId\n        tags: $tags\n        description: $description\n      }\n    ) {\n      persistedQuery {\n        id\n      }\n    }\n  }\n}\n\nquery ListPersistedQueries(\n  $appId: String!\n  $first: Int!\n  $after: String\n  $tags: [String!]!\n) {\n  oneGraph {\n    app(id: $appId) {\n      id\n      persistedQueries(\n        first: $first\n        after: $after\n        tags: $tags\n      ) {\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        nodes {\n          id\n          query\n          fixedVariables\n          freeVariables\n          allowedOperationNames\n          tags\n          description\n        }\n      }\n    }\n  }\n}\n\nsubscription ListPersistedQueriesSubscription(\n  $appId: String!\n  $first: Int!\n  $after: String\n  $tags: [String!]!\n) {\n  poll(\n    onlyTriggerWhenPayloadChanged: true\n    schedule: { every: { minutes: 1 } }\n  ) {\n    query {\n      oneGraph {\n        app(id: $appId) {\n          id\n          persistedQueries(\n            first: $first\n            after: $after\n            tags: $tags\n          ) {\n            pageInfo {\n              hasNextPage\n              endCursor\n            }\n            nodes {\n              id\n              query\n              fixedVariables\n              freeVariables\n              allowedOperationNames\n              tags\n              description\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nquery PersistedQueriesQuery(\n  $nfToken: String!\n  $appId: String!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    app(id: $appId) {\n      persistedQueries {\n        nodes {\n          id\n          query\n          allowedOperationNames\n          description\n          freeVariables\n          fixedVariables\n          tags\n        }\n      }\n    }\n  }\n}\n\nquery PersistedQueryQuery(\n  $nfToken: String!\n  $appId: String!\n  $id: String!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    persistedQuery(appId: $appId, id: $id) {\n      id\n      query\n      allowedOperationNames\n      description\n      freeVariables\n      fixedVariables\n      tags\n    }\n  }\n}\n\nmutation CreateCLISessionMutation(\n  $nfToken: String!\n  $appId: String!\n  $name: String!\n  $metadata: JSON\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    createNetlifyCliSession(\n      input: { appId: $appId, name: $name, metadata: metadata }\n    ) {\n      session {\n        id\n        appId\n        netlifyUserId\n        name\n      }\n    }\n  }\n}\n\nmutation UpdateCLISessionMetadataMutation(\n  $nfToken: String!\n  $sessionId: String!\n  $metadata: JSON!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    updateNetlifyCliSession(\n      input: { id: $sessionId, metadata: $metadata }\n    ) {\n      session {\n        id\n        name\n        metadata\n      }\n    }\n  }\n}\n\nmutation CreateCLISessionEventMutation(\n  $nfToken: String!\n  $sessionId: String!\n  $payload: JSON!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    createNetlifyCliTestEvent(\n      input: {\n        data: { payload: $payload }\n        sessionId: $sessionId\n      }\n    ) {\n      event {\n        id\n        createdAt\n        sessionId\n      }\n    }\n  }\n}\n  \nquery CLISessionEventsQuery(\n  $nfToken: String!\n  $sessionId: String!\n  $first: Int!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    netlifyCliEvents(sessionId: $sessionId, first: $first) {\n      __typename\n      createdAt\n      id\n      sessionId\n      ... on OneGraphNetlifyCliSessionLogEvent {\n        id\n        message\n        sessionId\n        createdAt\n      }\n      ... on OneGraphNetlifyCliSessionTestEvent {\n        id\n        createdAt\n        payload\n        sessionId\n      }\n    }\n  }\n}\n  \nmutation AckCLISessionEventMutation(\n  $nfToken: String!\n  $sessionId: String!\n  $eventIds: [String!]!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    ackNetlifyCliEvents(\n      input: { eventIds: $eventIds, sessionId: $sessionId }\n    ) {\n      events {\n        id\n      }\n    }\n  }\n}\n\nquery AppSchemaQuery(\n  $nfToken: String!\n  $appId: String!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    app(id: $appId) {\n      graphQLSchema {\n        appId\n        createdAt\n        id\n        services {\n          friendlyServiceName\n          logoUrl\n          service\n          slug\n          supportsCustomRedirectUri\n          supportsCustomServiceAuth\n          supportsOauthLogin\n        }\n        updatedAt\n      }\n    }\n  }\n}\n\nmutation UpsertAppForSiteMutation(\n  $nfToken: String!\n  $siteId: String!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    upsertAppForNetlifySite(\n      input: { netlifySiteId: $siteId }\n    ) {\n      org {\n        id\n        name\n      }\n      app {\n        id\n        name\n        corsOrigins\n        customCorsOrigins {\n          friendlyServiceName\n          displayName\n          encodedValue\n        }\n      }\n    }\n  }\n}\n\nmutation CreateNewSchemaMutation(\n  $nfToken: String!\n  $input: OneGraphCreateGraphQLSchemaInput!\n) {\n  oneGraph(\n    auths: { netlifyAuth: { oauthToken: $nfToken } }\n  ) {\n    createGraphQLSchema(input: $input) {\n      app {\n        graphQLSchema {\n          id\n        }\n      }\n      graphqlSchema {\n        id\n        services {\n          friendlyServiceName\n          logoUrl\n          service\n          slug\n          supportsCustomRedirectUri\n          supportsCustomServiceAuth\n          supportsOauthLogin\n        }\n      }\n    }\n  }\n}";
/**
 * Given an appId and desired services, fetch the schema (in json form) for that app
 * @param {string} appId
 * @param {string[]} enabledServices
 * @returns {Promise<object>} The schema for the app
 */
export declare const fetchOneGraphSchemaJson: (appId: string, enabledServices: string[]) => Promise<any>;
/**
 * Given an appId and desired services, fetch the schema json for an app and parse it into a GraphQL Schema
 * @param {string} appId
 * @param {string[]} enabledServices
 * @returns {Promise<GraphQLSchema>} The schema for the app
 */
export declare const fetchOneGraphSchema: (appId: string, enabledServices: string[]) => Promise<import("graphql").GraphQLSchema>;
export declare type PersistedQuery = {
    id: string;
    query: string;
    description: string | null;
    allowedOperationNames: string[];
    tags: string[];
};
/**
 * Fetch a persisted doc belonging to appId by its id
 * @param {string} authToken
 * @param {string} appId
 * @param {string} docId
 * @returns {string|undefined} The persisted operations doc
 */
export declare const fetchPersistedQuery: (authToken: string, appId: string, docId: string) => Promise<PersistedQuery | undefined>;
/**
 *
 * @param {object} options
 * @param {string} options.appId The app to query against, typically the siteId
 * @param {string} options.authToken The (typically netlify) access token that is used for authentication
 * @param {string} options.sessionId The session id to fetch CLI events for
 * @returns {Promise<OneGraphCliEvent[]|undefined>} The unhandled events for the cli session to process
 */
export declare const fetchCliSessionEvents: (options: {
    appId: string;
    authToken: string;
    sessionId: string;
}) => Promise<{
    events?: OneGraphCliEvent[] | undefined;
    errors?: any[] | undefined;
} | undefined>;
declare type OneGraphCliEvent = Record<string, any>;
/**
 * Register a new CLI session with OneGraph
 * @param {string} netlifyToken The netlify token to use for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} name The name of the CLI session, will be visible in the UI and CLI ouputs
 * @param {object} metadata Any additional metadata to attach to the session
 * @returns {Promise<object|undefined>} The CLI session object
 */
export declare const createCLISession: (netlifyToken: string, appId: string, name: string, metadata: Record<string, any>) => Promise<any>;
/**
 * Update the CLI session with new metadata (e.g. the latest docId) by its id
 * @param {string} netlifyToken The netlify token to use for authentication
 * @param {string} appId The app to query against, typically the siteId
 * @param {string} sessionId The session id to update
 * @param {object} metadata The new metadata to set on the session
 * @returns {Promise<object|undefined>} The updated session object
 */
export declare const updateCLISessionMetadata: (netlifyToken: string, appId: string, sessionId: string, metadata: Record<string, any>) => Promise<any>;
/**
 * Acknoledge CLI events that have been processed and delete them from the upstream queue
 * @param {object} input
 * @param {string} input.appId The app to query against, typically the siteId
 * @param {string} input.authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} input.sessionId The session id the events belong to
 * @param {string[]} input.eventIds The event ids to ack (and delete) from the session queue, having been processed
 * @returns
 */
export declare const ackCLISessionEvents: (input: {
    appId: string;
    authToken: string;
    sessionId: string;
    eventIds: string[];
}) => Promise<any>;
/**
 * Create a persisted operations doc to be later retrieved, usually from a GUI
 * @param {string} netlifyToken The netlify token to use for authentication
 * @param {object} input
 * @param {string} input.appId The app to query against, typically the siteId
 * @param {string} input.document The GraphQL operations document to persist
 * @param {string} input.description A description of the operations doc
 * @param {string[]} input.tags A list of tags to attach to the operations doc
 * @returns
 */
export declare const createPersistedQuery: (netlifyToken: string, { appId, description, document, tags, }: {
    appId: string;
    description: string;
    document: string;
    tags: string[];
}) => Promise<any>;
/**
 *
 * @param {OneGraphCliEvent} event
 * @returns {string} a human-friendly description of the event
 */
export declare const friendlyEventName: (event: OneGraphCliEvent) => any;
/**
 * Fetch the schema metadata for a site (enabled services, id, etc.)
 * @param {string} authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} siteId The site id to query against
 * @returns {Promise<object|undefined>} The schema metadata for the site
 */
export declare const fetchAppSchema: (authToken: string, siteId: string) => Promise<any>;
/**
 * If a site does not exists upstream in OneGraph for the given site, create it
 * @param {string} authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} siteId The site id to create an app for upstream on OneGraph
 * @returns
 */
export declare const upsertAppForSite: (authToken: string, siteId: string) => Promise<any>;
/**
 * Create a new schema in OneGraph for the given site with the specified metadata (enabled services, etc.)
 * @param {string} input.netlifyToken The (typically netlify) access token that is used for authentication, if any
 * @param {object} input The details of the schema to create
 * @returns {Promise<object>} The schema metadata for the site
 */
export declare const createNewAppSchema: (nfToken: string, input: {
    appId: string;
    enabledServices?: string[];
    setAsDefaultForApp?: boolean;
}) => Promise<any>;
/**
 * Ensure that an app exists upstream in OneGraph for the given site
 * @param {string} authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} siteId The site id to create an app for upstream on OneGraph
 * @returns
 */
export declare const ensureAppForSite: (authToken: string, siteId: string) => Promise<void>;
/**
 * Fetch a list of what services are enabled for the given site
 * @param {string} authToken The (typically netlify) access token that is used for authentication, if any
 * @param {string} appId The app id to query against
 * @returns
 */
export declare const fetchEnabledServices: (authToken: string, appId: string) => Promise<any>;
export {};
