"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.remixFunctionSnippet = exports.computeOperationDataList = exports.formElComponent = void 0;
var graphql_1 = require("graphql");
var codegenHelpers_1 = require("./codegenHelpers");
var internalConsole_1 = require("../internalConsole");
var graphqlHelpers_1 = require("../graphqlHelpers");
var operationNodesMemo = [null, null];
var formUpdateHandler = "const updateFormVariables = (setFormVariables, path, coerce) => {\n  const setIn = (object, path, value) => {\n    if (path.length === 1) {\n      if (value === null) {\n        delete object[path[0]];\n      } else {\n        object[path[0]] = value;\n      }\n    } else {\n      if ([undefined, null].indexOf(object[path[0]]) > -1) {\n        object[path[0]] = typeof path[1] === \"number\" ?  [] : {};\n      }\n      setIn(object[path[0]], path.slice(1), value);\n    }\n    return object;\n  };\n\n  const formInputHandler = (event) => {\n    // We parse the form input, coerce it to the correct type, and then update the form variables\n    const rawValue = event.target.value;\n    // We take a blank input to mean `null`\n    const value = rawValue === \"\" ? null : rawValue;\n    setFormVariables((oldFormVariables) => {\n      const newValue = setIn(oldFormVariables, path, coerce(value));\n      return { ...newValue };\n    });\n  };\n\n  return formInputHandler;\n};";
var formElComponent = function (_a) {
    var operationData = _a.operationData, schema = _a.schema, callFn = _a.callFn;
    if (!schema) {
        return {
            formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
            formEl: "<pre>You must pass in a schema to generate forms for your GraphQL operation</pre>",
        };
    }
    var els = (operationData.operationDefinition.variableDefinitions || []).map(function (def) {
        var genInput = (0, graphqlHelpers_1.remixFormInput)(schema, def, []);
        var input = genInput || "UNABLE_TO_GENERATE_FORM_INPUT_FOR_GRAPHQL_TYPE(" + def + ")";
        return "<p>" + input + "</p>";
    });
    return {
        formHelpers: "const [formVariables, setFormVariables] = React.useState({});",
        formEl: addLeftWhitespace(els.join("\n"), 2) + "\n  <p>\n    <button type=\"submit\">\n      {transition.submission\n        ? \"Submitting...\"\n        : \"Run " + operationData.displayName + "\"}\n    </button>\n  </p>\n",
    };
};
exports.formElComponent = formElComponent;
var generateRoute = function (opts) {
    var form = (0, exports.formElComponent)({
        operationData: opts.operationData,
        schema: opts.schema,
        callFn: "submitForm()",
    });
    var netlifyGraphConfig = opts.netlifyGraphConfig;
    var fetcherInvocation = asyncFetcherInvocation(opts.netlifyGraphConfig, [opts.operationData], "get");
    return {
        kind: "NamedExportedFile",
        name: [
            "app",
            "routes",
            opts.operationData.displayName + "." + (opts.netlifyGraphConfig.language === "typescript" ? "tsx" : "js"),
        ],
        content: "import { json, Form, useActionData, useTransition } from \"remix\";\nimport type { ActionFunction } from \"remix\";\nimport NetlifyGraph from \"" + netlifyGraphConfig.netlifyGraphRequirePath + "\";" + ts(netlifyGraphConfig, "\nimport invariant from \"tiny-invariant\";") + "\n\n" + exp(netlifyGraphConfig, "action") + ts(netlifyGraphConfig, ": ActionFunction") + " = async ({ request }) => {\nconst formData = await request.formData();\n\n// By default, all API calls use no authentication\nlet accessToken;\n\n//// If you want to use the API with your own access token:\n// accessToken = process.env.ONEGRAPH_AUTHLIFY_TOKEN;\n\n" + fetcherInvocation + "\n\nreturn json({ data, errors });\n};\n\nexport default function handler() {\n  const results = useActionData();\n  const transition = useTransition();\n\n  const errors = results?.errors;\n  const data" + ts(netlifyGraphConfig, ": NetlifyGraph." + capitalizeFirstLetter(opts.operationData.name) + "[\"data\"]") + " = results?.data;\n\n\n  return (\n    <Form method=\"post\">\n     " + form.formEl + "\n     {errors ? (<pre className=\"error\">{JSON.stringify(errors, null, 2)}</pre>) : null}\n     {data ? (<pre>{JSON.stringify(data, null, 2)}</pre>) : null}\n    </Form>\n  );\n}\n",
    };
};
var getOperationNodes = function (query) {
    if (operationNodesMemo[0] === query && operationNodesMemo[1]) {
        return operationNodesMemo[1];
    }
    var operationDefinitions = [];
    try {
        (0, graphql_1.parse)(query).definitions.forEach(function (def) {
            if (def.kind === "FragmentDefinition" ||
                def.kind === "OperationDefinition") {
                operationDefinitions.push(def);
            }
        });
    }
    catch (parseError) {
        // ignore
    }
    operationNodesMemo = [query, operationDefinitions];
    return operationDefinitions;
};
var getOperationName = function (operationDefinition) {
    return operationDefinition.name
        ? operationDefinition.name.value
        : operationDefinition.operation;
};
var getOperationDisplayName = function (operationDefinition) {
    return operationDefinition.name
        ? operationDefinition.name.value
        : "<Unnamed:" + operationDefinition.operation + ">";
};
var formatVariableName = function (name) {
    var uppercasePattern = /[A-Z]/g;
    return (name.charAt(0).toUpperCase() +
        name.slice(1).replace(uppercasePattern, "_$&").toUpperCase());
};
var getUsedVariables = function (variables, operationDefinition) {
    return (operationDefinition.variableDefinitions || []).reduce(function (usedVariables, variable) {
        var variableName = variable.variable.name.value;
        if (variables[variableName]) {
            usedVariables[variableName] = variables[variableName];
        }
        return usedVariables;
    }, {});
};
var findFragmentDependencies = function (operationDefinitions, definition) {
    var fragmentByName = function (name) {
        return operationDefinitions.find(function (def) { return def.name.value === name; });
    };
    var findReferencedFragments = function (selectionSet) {
        var selections = selectionSet.selections;
        var namedFragments = selections
            .map(function (selection) {
            if (selection.kind === "FragmentSpread") {
                return fragmentByName(selection.name.value);
            }
            return null;
        })
            .filter(Boolean);
        var nestedNamedFragments = selections.reduce(function (acc, selection) {
            if ((selection.kind === "Field" ||
                selection.kind === "SelectionNode" ||
                selection.kind === "InlineFragment") &&
                selection.selectionSet !== undefined) {
                return __spreadArray(__spreadArray([], acc, true), findReferencedFragments(selection.selectionSet), true);
            }
            return acc;
        }, []);
        return __spreadArray(__spreadArray([], namedFragments, true), nestedNamedFragments, true);
    };
    var selectionSet = definition.selectionSet;
    return findReferencedFragments(selectionSet);
};
var operationDataByName = function (graph, name) {
    return graph.find(function (operationData) { return operationData.name === name; });
};
var topologicalSortHelper = function (_a, result) {
    var graph = _a.graph, node = _a.node, temp = _a.temp, visited = _a.visited;
    temp[node.name] = true;
    var neighbors = node.fragmentDependencies;
    neighbors.forEach(function (fragmentDependency) {
        var fragmentOperationData = operationDataByName(graph, fragmentDependency.name.value);
        if (!fragmentOperationData) {
            return;
        }
        if (temp[fragmentOperationData.name]) {
            internalConsole_1.internalConsole.error("The operation graph has a cycle");
            return;
        }
        if (!visited[fragmentOperationData.name]) {
            topologicalSortHelper({
                node: fragmentOperationData,
                visited: visited,
                temp: temp,
                graph: graph,
            }, result);
        }
    });
    temp[node.name] = false;
    visited[node.name] = true;
    result.push(node);
};
var toposort = function (graph) {
    var result = [];
    var visited = {};
    var temp = {};
    graph.forEach(function (node) {
        if (!visited[node.name] && !temp[node.name]) {
            topologicalSortHelper({ node: node, visited: visited, temp: temp, graph: graph }, result);
        }
    });
    return result;
};
var computeOperationDataList = function (_a) {
    var query = _a.query, variables = _a.variables;
    var operationDefinitions = getOperationNodes(query);
    var fragmentDefinitions = [];
    operationDefinitions.forEach(function (operationDefinition) {
        if (operationDefinition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
            fragmentDefinitions.push(operationDefinition);
        }
    });
    var rawOperationDataList = operationDefinitions.map(function (operationDefinition) { return ({
        query: (0, graphql_1.print)(operationDefinition),
        name: getOperationName(operationDefinition),
        displayName: getOperationDisplayName(operationDefinition),
        type: operationDefinition.kind === graphql_1.Kind.OPERATION_DEFINITION
            ? operationDefinition.operation
            : graphql_1.Kind.FRAGMENT_DEFINITION,
        variableName: formatVariableName(getOperationName(operationDefinition)),
        variables: getUsedVariables(variables, operationDefinition),
        operationDefinition: operationDefinition,
        fragmentDependencies: findFragmentDependencies(fragmentDefinitions, operationDefinition),
    }); });
    var operationDataList = toposort(rawOperationDataList);
    return {
        operationDefinitions: operationDefinitions,
        fragmentDefinitions: fragmentDefinitions,
        rawOperationDataList: rawOperationDataList,
        operationDataList: operationDataList,
    };
};
exports.computeOperationDataList = computeOperationDataList;
var capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
var unnamedSymbols = new Set(["query", "mutation", "subscription"]);
var isOperationNamed = function (operationData) {
    return !unnamedSymbols.has(operationData.name.trim());
};
var addLeftWhitespace = function (string, padding) {
    var paddingString = " ".repeat(padding);
    return string
        .split("\n")
        .map(function (line) { return paddingString + line; })
        .join("\n");
};
var collapseExtraNewlines = function (string) { return string.replace(/\n{2,}/g, "\n\n"); };
var snippetOptions = [
    {
        id: "postHttpMethod",
        label: "POST function",
        initial: true,
    },
    {
        id: "useClientAuth",
        label: "Use user's OAuth token",
        initial: false,
    },
];
var operationFunctionName = function (operationData) {
    var type = operationData.type;
    var prefix = "unknown";
    switch (type) {
        case "query":
            prefix = "fetch";
            break;
        case "mutation":
            prefix = "execute";
            break;
        case "subscription":
            prefix = "subscribeTo";
            break;
        default:
            break;
    }
    var fnName = prefix +
        (prefix.length === 0
            ? operationData.name
            : capitalizeFirstLetter(operationData.name));
    return fnName;
};
var coercerFor = function (type, name) {
    var typeName = (0, graphql_1.print)(type).replace(/\W+/gi, "").toLocaleLowerCase();
    switch (typeName) {
        case "string":
            return "" + name;
        case "int":
            return "parseInt(" + name + ")";
        case "float":
            return "parseFloat(" + name + ")";
        case "boolean":
            return name + " === 'true'";
        default:
            return "" + name;
    }
};
var asyncFetcherInvocation = function (netlifyGraphConfig, operationDataList, pluckerStyle) {
    var invocations = operationDataList
        .filter(function (operationData) {
        return ["query", "mutation", "subscription"].includes(operationData.type);
    })
        .map(function (namedOperationData) {
        var _a, _b, _c, _d, _e;
        var params = (namedOperationData.operationDefinition.variableDefinitions || []).map(function (def) { return def.variable.name.value; });
        var invocationParams = params.map(function (param) { return param + ": " + (0, codegenHelpers_1.munge)(param); });
        var pluckers = {
            get: ((_b = (_a = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _a === void 0 ? void 0 : _a.variableDefinitions) === null || _b === void 0 ? void 0 : _b.map(function (def) {
                var name = def.variable.name.value;
                var withCoercer = coercerFor(def.type, (0, codegenHelpers_1.munge)(name) + "FormValue");
                return "const " + (0, codegenHelpers_1.munge)(name) + "FormValue = formData.get(\"" + name + "\");" + ts(netlifyGraphConfig, "\ninvariant(typeof " + (0, codegenHelpers_1.munge)(name) + "FormValue === \"string\");") + "\nconst " + (0, codegenHelpers_1.munge)(name) + " = " + withCoercer + ";\n";
            }).join("\n  ")) || "",
            post: ((_d = (_c = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _c === void 0 ? void 0 : _c.variableDefinitions) === null || _d === void 0 ? void 0 : _d.map(function (def) {
                var name = def.variable.name.value;
                return "const " + (0, codegenHelpers_1.munge)(name) + " = eventBodyJson?." + name + ";";
            }).join("\n  ")) || "",
        };
        var variableValidation = "";
        var requiredVariableCount = 0;
        if ((((_e = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _e === void 0 ? void 0 : _e.variableDefinitions) || [])
            .length !== 0 ||
            0) {
            var requiredVariableNames = namedOperationData.operationDefinition.variableDefinitions
                .map(function (def) {
                return (0, graphql_1.print)(def.type).endsWith("!") ? def.variable.name.value : null;
            })
                .filter(Boolean);
            requiredVariableCount = requiredVariableNames.length;
            // TODO: Filter nullable variables
            var condition = requiredVariableNames
                .map(function (name) { return (0, codegenHelpers_1.munge)(name) + " === undefined || " + (0, codegenHelpers_1.munge)(name) + " === null"; })
                .join(" || ");
            var message = requiredVariableNames
                .map(function (name) { return "`" + name + "`"; })
                .join(", ");
            variableValidation = "  if (" + condition + ") {\n    return json(\n      {\n        errors: [\"You must supply parameters for: " + message + "\"],\n      },\n      { status: 422 }\n    );\n  }";
        }
        return (pluckerStyle === "get" ? pluckers.get : pluckers.post) + "\n\n" + (requiredVariableCount > 0 ? variableValidation : "") + "\n\n  const { errors, data } = await NetlifyGraph." + operationFunctionName(namedOperationData) + "({ " + invocationParams.join(", ") + " }, accessToken);\n\n  if (errors) {\n    console.error(JSON.stringify(errors, null, 2));\n  }\n\n  console.log(JSON.stringify(data, null, 2));";
    })
        .join("\n\n");
    return invocations;
};
var clientSideInvocations = function (operationDataList, pluckerStyle, useClientAuth) {
    var invocations = operationDataList
        .filter(function (operationData) {
        return ["query", "mutation", "subscription"].includes(operationData.type);
    })
        .map(function (namedOperationData) {
        var _a, _b;
        var whitespace = 8;
        var params = (namedOperationData.operationDefinition.variableDefinitions || []).map(function (def) { return def.variable.name.value; });
        var bodyPayload = "";
        if (((_b = (_a = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _a === void 0 ? void 0 : _a.variableDefinitions) === null || _b === void 0 ? void 0 : _b.length) ||
            0 > 0) {
            var variableNames = namedOperationData.operationDefinition.variableDefinitions.map(function (def) { return def.variable.name.value; });
            var variables = variableNames
                .map(function (name) { return "\"" + name + "\": " + name; })
                .join(",\n");
            bodyPayload = "\n" + variables + "\n";
        }
        var clientAuth = useClientAuth
            ? ",\n    ...netlifyGraphAuth?.authHeaders()"
            : "";
        var headers = "headers: {\n      \"Content-Type\": \"application/json\"" + clientAuth + "\n    },";
        return "async function " + operationFunctionName(namedOperationData) + "(" + (useClientAuth ? "netlifyGraphAuth, " : "") + "params) {\n  const {" + params.join(", ") + "} = params || {};\n  const resp = await fetch(`/" + namedOperationData.name + (pluckerStyle === "get"
            ? "?" + params.map(function (param) { return param + "=${" + param + "}"; }).join("&")
            : "") + "`, {\n    method: \"" + pluckerStyle.toLocaleUpperCase() + "\"" + (pluckerStyle === "get"
            ? ""
            : ",\n    " + headers + "\n    body: JSON.stringify({" + addLeftWhitespace(bodyPayload, whitespace).trim() + "})") + "\n  });\n\n  const text = await resp.text();\n\n  return JSON.parse(text);\n}";
    })
        .join("\n\n");
    return invocations;
};
var ts = function (netlifyGraphConfig, string) {
    return netlifyGraphConfig.language === "typescript" ? string : "";
};
var subscriptionHandler = function (_a) {
    var netlifyGraphConfig = _a.netlifyGraphConfig, operationData = _a.operationData;
    return {
        kind: "NamedExportedFile",
        name: [
            "app",
            "routes",
            "webhooks",
            operationData.displayName + "." + (netlifyGraphConfig.language === "typescript" ? "tsx" : "js"),
        ],
        content: "import { " + ts(netlifyGraphConfig, "ActionFunction, ") + "json } from \"remix\";\nimport NetlifyGraph from \"../" + netlifyGraphConfig.netlifyGraphRequirePath + "\";\n\n" + exp(netlifyGraphConfig, "action") + ts(netlifyGraphConfig, ": ActionFunction") + " = async ({ request }) => {\n  const reqBody = await request.text();\n\n  const payload = NetlifyGraph.parseAndVerify" + operationData.name + "Event({\n    body: reqBody,\n    headers: {\n      'x-netlify-graph-signature': request.headers.get('x-netlify-graph-signature')\n    },\n  });\n\n  if (!payload) {\n    return json({\n      success: false,\n      error: 'Unable to verify payload signature',\n    }, { status: 422 });\n  }\n\n  const { errors, data } = payload;\n\n  if (errors) {\n    console.error(errors);\n  }\n\n  console.log(data);\n\n  /**\n   * If you want to unsubscribe from this webhook\n   * in order to stop receiving new events,\n   * simply return status 410, e.g.:\n   * \n   * return json({}, { status: 410 });\n   */\n\n  return json({\n    successfullyProcessedIncomingWebhook: true,\n  });\n};\n",
    };
};
var imp = function (netlifyGraphConfig, name, packageName) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "const " + name + " = require(\"" + packageName.join("/") + "\")";
    }
    return "import " + name + " from \"" + packageName.join("/") + "\"";
};
var exp = function (netlifyGraphConfig, name) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports." + name;
    }
    return "export const " + name;
};
var expDefault = function (netlifyGraphConfig, name) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports.default = " + name;
    }
    return "export default " + name;
};
// Snippet generation!
exports.remixFunctionSnippet = {
    language: "JavaScript",
    codeMirrorMode: "javascript",
    name: "Remix Function",
    options: snippetOptions,
    generate: function (opts) {
        var netlifyGraphConfig = opts.netlifyGraphConfig, options = opts.options;
        var operationDataList = opts.operationDataList.map(function (operationData, idx) {
            if (!isOperationNamed(operationData)) {
                return __assign(__assign({}, operationData), { name: ("unnamed" + capitalizeFirstLetter(operationData.type) + (idx + 1)).trim(), query: "# Consider giving this " + operationData.type + " a unique, descriptive\n# name in your application as a best practice\n" + operationData.type + " unnamed" + capitalizeFirstLetter(operationData.type) + (idx + 1) + " " + operationData.query
                        .trim()
                        .replace(/^(query|mutation|subscription) /i, "") });
            }
            return operationData;
        });
        var firstOperation = operationDataList.find(function (operation) {
            return operation.operationDefinition.kind === "OperationDefinition";
        });
        if (!firstOperation) {
            return {
                language: "javascript",
                exportedFiles: [
                    {
                        kind: "UnnamedExportedFile",
                        content: "// No operation found",
                    },
                ],
            };
        }
        var filename = firstOperation.name + "." + netlifyGraphConfig.extension;
        var isSubscription = firstOperation.type === "subscription";
        if (isSubscription) {
            var result = subscriptionHandler({
                netlifyGraphConfig: netlifyGraphConfig,
                operationData: firstOperation,
            });
            return {
                language: netlifyGraphConfig.language,
                exportedFiles: [result],
            };
        }
        var passThroughResults = operationDataList.length === 1
            ? "errors, data"
            : operationDataList
                .filter(function (operationData) {
                return ["query", "mutation", "subscription"].includes(operationData.type);
            })
                .map(function (_operationData) { return "errors,\ndata"; })
                .join(",\n");
        var clientSideCalls = clientSideInvocations(operationDataList, options.postHttpMethod === true ? "post" : "get", options.useClientAuth);
        var whitespace = 4;
        var snippet = ts(netlifyGraphConfig, 'import type { NextApiRequest, NextApiResponse } from "next";') + "\n" + imp(netlifyGraphConfig, "NetlifyGraph", netlifyGraphConfig.netlifyGraphRequirePath) + ";\n\n/** \n * Client-side invocations:\n * Call your Netlify function from the browser with this helper:\n */\n\n/**\n" + clientSideCalls + "\n*/";
        var route = generateRoute({
            netlifyGraphConfig: netlifyGraphConfig,
            operationData: firstOperation,
            schema: opts.schema,
            route: "/" + firstOperation.displayName,
        });
        return {
            language: "javascript",
            exportedFiles: [route],
        };
    },
};
//# sourceMappingURL=remixExporter.js.map