"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nextjsFunctionSnippet = exports.computeOperationDataList = void 0;
var graphql_1 = require("graphql");
var codegenHelpers_1 = require("./codegenHelpers");
var internalConsole_1 = require("../internalConsole");
var graphqlHelpers_1 = require("../graphqlHelpers");
var operationNodesMemo = [null, null];
var formUpdateHandler = "const updateFormVariables = (setFormVariables, path, coerce) => {\n  const setIn = (object, path, value) => {\n    if (path.length === 1) {\n      if (value === null) {\n        delete object[path[0]];\n      } else {\n        object[path[0]] = value;\n      }\n    } else {\n      if ([undefined, null].indexOf(object[path[0]]) > -1) {\n        object[path[0]] = typeof path[1] === \"number\" ?  [] : {};\n      }\n      setIn(object[path[0]], path.slice(1), value);\n    }\n    return object;\n  };\n\n  const formInputHandler = (event) => {\n    // We parse the form input, coerce it to the correct type, and then update the form variables\n    const rawValue = event.target.value;\n    // We take a blank input to mean `null`\n    const value = rawValue === \"\" ? null : rawValue;\n    setFormVariables((oldFormVariables) => {\n      const newValue = setIn(oldFormVariables, path, coerce(value));\n      return { ...newValue };\n    });\n  };\n\n  return formInputHandler;\n};";
var generatePage = function (opts) {
    var form = (0, graphqlHelpers_1.formElComponent)({
        operationData: opts.operationData,
        schema: opts.schema,
        callFn: "submitForm()",
    });
    return {
        kind: "NamedExportedFile",
        name: ["pages", opts.operationData.displayName + "Form.tsx"],
        content: "import Head from \"next/head\";\nimport React, { useState } from \"react\";\nimport NetlifyGraphAuth from \"netlify-graph-auth\";\n\nexport default function Form(props) {\n  const isServer = typeof window === \"undefined\";\n  " + form.formHelpers + "\n  const [result, setResult] = useState(null);\n  const [auth, setAuth] = useState(\n    isServer\n      ? null\n      : new NetlifyGraphAuth({\n          siteId: props.siteId,\n        })\n  );\n\n  const submitForm = async () => {\n    const res = await fetch(\"" + opts.route + "\", {\n      body: JSON.stringify(formVariables),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...auth?.authHeaders()\n      },\n      method: \"POST\"\n    });\n\n    const formResult = await res.json();\n    setResult(formResult);\n  };\n\n  const needsLoginService = auth?.findMissingAuthServices(result)[0];\n\n  return (\n    <div className=\"container\">\n      <Head>\n        <title>" + opts.operationData.displayName + " form</title>\n      </Head>\n      <main>\n        <h1>{props.title}</h1>\n" + addLeftWhitespace(form.formEl, 8) + "\n        {needsLoginService ? (\n          <button\n          onClick={async () => {\n            await auth.login(needsLoginService);\n            const loginSuccess = await auth.isLoggedIn(needsLoginService);\n            if (loginSuccess) {\n              console.log(\"Successfully logged into \" + needsLoginService);\n              submitForm();\n            } else {\n              console.log(\"The user did not grant auth to \" + needsLoginService);\n            }\n          }}\n        >\n          {`Log in to ${needsLoginService}`}\n        </button>) \n        : null}\n        <pre>{JSON.stringify(formVariables, null, 2)}</pre>\n        <pre>{JSON.stringify(result, null, 2)}</pre>\n      </main>\n    </div>\n  )\n}\n\nexport async function getServerSideProps(context) {\n  const siteId = process.env.SITE_ID;\n  if (!siteId) {\n    throw new Error(\"SITE_ID environment variable is not set. Be sure to run `netlify link` before `netlify dev`\");\n  }\n\n  return {\n    props: {\n      title: \"" + opts.operationData.displayName + " form\",\n      siteId: siteId\n    }\n  }\n}\n\n" + formUpdateHandler + "\n",
    };
};
var getOperationNodes = function (query) {
    if (operationNodesMemo[0] === query && operationNodesMemo[1]) {
        return operationNodesMemo[1];
    }
    var operationDefinitions = [];
    try {
        (0, graphql_1.parse)(query).definitions.forEach(function (def) {
            if (def.kind === "FragmentDefinition" ||
                def.kind === "OperationDefinition") {
                operationDefinitions.push(def);
            }
        });
    }
    catch (parseError) {
        // ignore
    }
    operationNodesMemo = [query, operationDefinitions];
    return operationDefinitions;
};
var getOperationName = function (operationDefinition) {
    return operationDefinition.name
        ? operationDefinition.name.value
        : operationDefinition.operation;
};
var getOperationDisplayName = function (operationDefinition) {
    return operationDefinition.name
        ? operationDefinition.name.value
        : "<Unnamed:" + operationDefinition.operation + ">";
};
var formatVariableName = function (name) {
    var uppercasePattern = /[A-Z]/g;
    return (name.charAt(0).toUpperCase() +
        name.slice(1).replace(uppercasePattern, "_$&").toUpperCase());
};
var getUsedVariables = function (variables, operationDefinition) {
    return (operationDefinition.variableDefinitions || []).reduce(function (usedVariables, variable) {
        var variableName = variable.variable.name.value;
        if (variables[variableName]) {
            usedVariables[variableName] = variables[variableName];
        }
        return usedVariables;
    }, {});
};
var findFragmentDependencies = function (operationDefinitions, definition) {
    var fragmentByName = function (name) {
        return operationDefinitions.find(function (def) { return def.name.value === name; });
    };
    var findReferencedFragments = function (selectionSet) {
        var selections = selectionSet.selections;
        var namedFragments = selections
            .map(function (selection) {
            if (selection.kind === "FragmentSpread") {
                return fragmentByName(selection.name.value);
            }
            return null;
        })
            .filter(Boolean);
        var nestedNamedFragments = selections.reduce(function (acc, selection) {
            if ((selection.kind === "Field" ||
                selection.kind === "SelectionNode" ||
                selection.kind === "InlineFragment") &&
                selection.selectionSet !== undefined) {
                return __spreadArray(__spreadArray([], acc, true), findReferencedFragments(selection.selectionSet), true);
            }
            return acc;
        }, []);
        return __spreadArray(__spreadArray([], namedFragments, true), nestedNamedFragments, true);
    };
    var selectionSet = definition.selectionSet;
    return findReferencedFragments(selectionSet);
};
var operationDataByName = function (graph, name) {
    return graph.find(function (operationData) { return operationData.name === name; });
};
var topologicalSortHelper = function (_a, result) {
    var graph = _a.graph, node = _a.node, temp = _a.temp, visited = _a.visited;
    temp[node.name] = true;
    var neighbors = node.fragmentDependencies;
    neighbors.forEach(function (fragmentDependency) {
        var fragmentOperationData = operationDataByName(graph, fragmentDependency.name.value);
        if (!fragmentOperationData) {
            return;
        }
        if (temp[fragmentOperationData.name]) {
            internalConsole_1.internalConsole.error("The operation graph has a cycle");
            return;
        }
        if (!visited[fragmentOperationData.name]) {
            topologicalSortHelper({
                node: fragmentOperationData,
                visited: visited,
                temp: temp,
                graph: graph,
            }, result);
        }
    });
    temp[node.name] = false;
    visited[node.name] = true;
    result.push(node);
};
var toposort = function (graph) {
    var result = [];
    var visited = {};
    var temp = {};
    graph.forEach(function (node) {
        if (!visited[node.name] && !temp[node.name]) {
            topologicalSortHelper({ node: node, visited: visited, temp: temp, graph: graph }, result);
        }
    });
    return result;
};
var computeOperationDataList = function (_a) {
    var query = _a.query, variables = _a.variables;
    var operationDefinitions = getOperationNodes(query);
    var fragmentDefinitions = [];
    operationDefinitions.forEach(function (operationDefinition) {
        if (operationDefinition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
            fragmentDefinitions.push(operationDefinition);
        }
    });
    var rawOperationDataList = operationDefinitions.map(function (operationDefinition) { return ({
        query: (0, graphql_1.print)(operationDefinition),
        name: getOperationName(operationDefinition),
        displayName: getOperationDisplayName(operationDefinition),
        type: operationDefinition.kind === graphql_1.Kind.OPERATION_DEFINITION
            ? operationDefinition.operation
            : graphql_1.Kind.FRAGMENT_DEFINITION,
        variableName: formatVariableName(getOperationName(operationDefinition)),
        variables: getUsedVariables(variables, operationDefinition),
        operationDefinition: operationDefinition,
        fragmentDependencies: findFragmentDependencies(fragmentDefinitions, operationDefinition),
    }); });
    var operationDataList = toposort(rawOperationDataList);
    return {
        operationDefinitions: operationDefinitions,
        fragmentDefinitions: fragmentDefinitions,
        rawOperationDataList: rawOperationDataList,
        operationDataList: operationDataList,
    };
};
exports.computeOperationDataList = computeOperationDataList;
var capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
var unnamedSymbols = new Set(["query", "mutation", "subscription"]);
var isOperationNamed = function (operationData) {
    return !unnamedSymbols.has(operationData.name.trim());
};
var addLeftWhitespace = function (string, padding) {
    var paddingString = " ".repeat(padding);
    return string
        .split("\n")
        .map(function (line) { return paddingString + line; })
        .join("\n");
};
var collapseExtraNewlines = function (string) { return string.replace(/\n{2,}/g, "\n\n"); };
var snippetOptions = [
    {
        id: "postHttpMethod",
        label: "POST function",
        initial: true,
    },
    {
        id: "useClientAuth",
        label: "Use user's OAuth token",
        initial: false,
    },
];
var operationFunctionName = function (operationData) {
    var type = operationData.type;
    var prefix = "unknown";
    switch (type) {
        case "query":
            prefix = "fetch";
            break;
        case "mutation":
            prefix = "execute";
            break;
        case "subscription":
            prefix = "subscribeTo";
            break;
        default:
            break;
    }
    var fnName = prefix +
        (prefix.length === 0
            ? operationData.name
            : capitalizeFirstLetter(operationData.name));
    return fnName;
};
var coercerFor = function (type, name) {
    var typeName = (0, graphql_1.print)(type).replace(/\W+/gi, "").toLocaleLowerCase();
    switch (typeName) {
        case "string":
            return "" + name;
        case "int":
            return "parseInt(" + name + ")";
        case "float":
            return "parseFloat(" + name + ")";
        case "boolean":
            return name + " === 'true'";
        default:
            return "" + name;
    }
};
var asyncFetcherInvocation = function (operationDataList, pluckerStyle) {
    var invocations = operationDataList
        .filter(function (operationData) {
        return ["query", "mutation", "subscription"].includes(operationData.type);
    })
        .map(function (namedOperationData) {
        var _a, _b, _c, _d, _e;
        var params = (namedOperationData.operationDefinition.variableDefinitions || []).map(function (def) { return def.variable.name.value; });
        var invocationParams = params.map(function (param) { return param + ": " + (0, codegenHelpers_1.munge)(param); });
        var pluckers = {
            get: ((_b = (_a = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _a === void 0 ? void 0 : _a.variableDefinitions) === null || _b === void 0 ? void 0 : _b.map(function (def) {
                var name = def.variable.name.value;
                var withCoercer = coercerFor(def.type, "req.query?." + name);
                return "const " + (0, codegenHelpers_1.munge)(name) + " = " + withCoercer + ";";
            }).join("\n  ")) || "",
            post: ((_d = (_c = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _c === void 0 ? void 0 : _c.variableDefinitions) === null || _d === void 0 ? void 0 : _d.map(function (def) {
                var name = def.variable.name.value;
                return "const " + (0, codegenHelpers_1.munge)(name) + " = eventBodyJson?." + name + ";";
            }).join("\n  ")) || "",
        };
        var variableValidation = "";
        var requiredVariableCount = 0;
        if ((((_e = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _e === void 0 ? void 0 : _e.variableDefinitions) || [])
            .length !== 0 ||
            0) {
            var requiredVariableNames = namedOperationData.operationDefinition.variableDefinitions
                .map(function (def) {
                return (0, graphql_1.print)(def.type).endsWith("!") ? def.variable.name.value : null;
            })
                .filter(Boolean);
            requiredVariableCount = requiredVariableNames.length;
            // TODO: Filter nullable variables
            var condition = requiredVariableNames
                .map(function (name) { return (0, codegenHelpers_1.munge)(name) + " === undefined || " + (0, codegenHelpers_1.munge)(name) + " === null"; })
                .join(" || ");
            var message = requiredVariableNames
                .map(function (name) { return "`" + name + "`"; })
                .join(", ");
            variableValidation = "  if (" + condition + ") {\n    return json(\n      {\n        errors: [\"You must supply parameters for: " + message + "\"],\n      },\n      { status: 422 }\n    );\n  }";
        }
        return (pluckerStyle === "get" ? pluckers.get : pluckers.post) + "\n\n" + (requiredVariableCount > 0 ? variableValidation : "") + "\n\n  const { errors, data } = await NetlifyGraph." + operationFunctionName(namedOperationData) + "({ " + invocationParams.join(", ") + " }, accessToken);\n\n  if (errors) {\n    console.error(JSON.stringify(errors, null, 2));\n  }\n\n  console.log(JSON.stringify(data, null, 2));";
    })
        .join("\n\n");
    return invocations;
};
var clientSideInvocations = function (operationDataList, pluckerStyle, useClientAuth) {
    var invocations = operationDataList
        .filter(function (operationData) {
        return ["query", "mutation", "subscription"].includes(operationData.type);
    })
        .map(function (namedOperationData) {
        var _a, _b;
        var whitespace = 8;
        var params = (namedOperationData.operationDefinition.variableDefinitions || []).map(function (def) { return def.variable.name.value; });
        var bodyPayload = "";
        if (((_b = (_a = namedOperationData === null || namedOperationData === void 0 ? void 0 : namedOperationData.operationDefinition) === null || _a === void 0 ? void 0 : _a.variableDefinitions) === null || _b === void 0 ? void 0 : _b.length) ||
            0 > 0) {
            var variableNames = namedOperationData.operationDefinition.variableDefinitions.map(function (def) { return def.variable.name.value; });
            var variables = variableNames
                .map(function (name) { return "\"" + name + "\": " + name; })
                .join(",\n");
            bodyPayload = "\n" + variables + "\n";
        }
        var clientAuth = useClientAuth
            ? ",\n    ...netlifyGraphAuth?.authHeaders()"
            : "";
        var headers = "headers: {\n      \"Content-Type\": \"application/json\"" + clientAuth + "\n    },";
        return "async function " + operationFunctionName(namedOperationData) + "(" + (useClientAuth ? "netlifyGraphAuth, " : "") + "params) {\n  const {" + params.join(", ") + "} = params || {};\n  const resp = await fetch(`/api/" + namedOperationData.name + (pluckerStyle === "get"
            ? "?" + params.map(function (param) { return param + "=${" + param + "}"; }).join("&")
            : "") + "`, {\n    method: \"" + pluckerStyle.toLocaleUpperCase() + "\"" + (pluckerStyle === "get"
            ? ""
            : ",\n    " + headers + "\n    body: JSON.stringify({" + addLeftWhitespace(bodyPayload, whitespace).trim() + "})") + "\n  });\n\n  const text = await resp.text();\n\n  return JSON.parse(text);\n}";
    })
        .join("\n\n");
    return invocations;
};
var ts = function (netlifyGraphConfig, string) {
    return netlifyGraphConfig.language === "typescript" ? string : "";
};
var subscriptionHandler = function (_a) {
    var netlifyGraphConfig = _a.netlifyGraphConfig, operationData = _a.operationData;
    return {
        kind: "UnnamedExportedFile",
        content: "" + ts(netlifyGraphConfig, 'import type { NextApiRequest, NextApiResponse } from "next";\n') + imp(netlifyGraphConfig, "NetlifyGraph", netlifyGraphConfig.netlifyGraphRequirePath) + ";\n\n" + exp(netlifyGraphConfig, "handler") + " = async (req" + ts(netlifyGraphConfig, ": NextApiRequest") + ", res" + ts(netlifyGraphConfig, ": NextApiResponse") + ") => {\n  const reqBody = await extractBody(req);\n\n  const payload = NetlifyGraph.parseAndVerify" + operationData.name + "Event({\n    headers: req.headers,\n    body: reqBody,\n  });\n\n  if (!payload) {\n    return res.status(422).json({\n      success: false,\n      error: 'Unable to verify payload signature',\n    });\n  }\n\n  const { errors, data } = payload;\n\n  if (errors) {\n    console.error(errors);\n  }\n\n  console.log(data);\n\n  res.setHeader(\"Content-Type\", \"application/json\");\n\n  /**\n   * If you want to unsubscribe from this webhook\n   * in order to stop receiving new events,\n   * simply return status 410, e.g.:\n   * \n   * return res.status(410).json({});\n   */\n\n  return res.status(200).json({\n    successfullyProcessedIncomingWebhook: true,\n  });\n};\n\n" + expDefault(netlifyGraphConfig, "handler") + ";\n\nexport const config = {\n  api: {\n    // We manually parse the body of the request in order to verify\n    // that it's signed by Netlify before processing the event.\n    bodyParser: false,\n  },\n};\n\nconst extractBody = (req" + ts(netlifyGraphConfig, ": NextApiRequest") + ")" + ts(netlifyGraphConfig, ": Promise<string>") + " => {\n  let body = [];\n  const promise" + ts(netlifyGraphConfig, ": Promise<string>") + " = new Promise((resolve, reject) => {\n    req\n      .on(\"data\", (chunk) => {\n        body.push(chunk);\n      })\n      .on(\"end\", () => {\n        const fullBody = Buffer.concat(body).toString();\n        resolve(fullBody);\n      });\n  });\n\n  return promise;\n};\n",
    };
};
var imp = function (netlifyGraphConfig, name, packageName) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "const " + name + " = require(\"" + packageName.join("/") + "\")";
    }
    return "import " + name + " from \"" + packageName.join("/") + "\"";
};
var exp = function (netlifyGraphConfig, name) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports." + name;
    }
    return "export const " + name;
};
var expDefault = function (netlifyGraphConfig, name) {
    if (netlifyGraphConfig.moduleType === "commonjs") {
        return "exports.default = " + name;
    }
    return "export default " + name;
};
// Snippet generation!
exports.nextjsFunctionSnippet = {
    language: "JavaScript",
    codeMirrorMode: "javascript",
    name: "Next.js Function",
    options: snippetOptions,
    generate: function (opts) {
        var netlifyGraphConfig = opts.netlifyGraphConfig, options = opts.options;
        var operationDataList = opts.operationDataList.map(function (operationData, idx) {
            if (!isOperationNamed(operationData)) {
                return __assign(__assign({}, operationData), { name: ("unnamed" + capitalizeFirstLetter(operationData.type) + (idx + 1)).trim(), query: "# Consider giving this " + operationData.type + " a unique, descriptive\n# name in your application as a best practice\n" + operationData.type + " unnamed" + capitalizeFirstLetter(operationData.type) + (idx + 1) + " " + operationData.query
                        .trim()
                        .replace(/^(query|mutation|subscription) /i, "") });
            }
            return operationData;
        });
        var firstOperation = operationDataList.find(function (operation) {
            return operation.operationDefinition.kind === "OperationDefinition";
        });
        if (!firstOperation) {
            return {
                language: "javascript",
                exportedFiles: [
                    {
                        kind: "UnnamedExportedFile",
                        content: "// No operation found",
                    },
                ],
            };
        }
        var filename = firstOperation.name + "." + netlifyGraphConfig.extension;
        var isSubscription = firstOperation.type === "subscription";
        if (isSubscription) {
            var result = subscriptionHandler({
                netlifyGraphConfig: netlifyGraphConfig,
                operationData: firstOperation,
            });
            return {
                language: netlifyGraphConfig.language,
                exportedFiles: [result],
            };
        }
        var fetcherInvocation = asyncFetcherInvocation(operationDataList, options.postHttpMethod === true ? "post" : "get");
        var passThroughResults = operationDataList.length === 1
            ? "errors, data"
            : operationDataList
                .filter(function (operationData) {
                return ["query", "mutation", "subscription"].includes(operationData.type);
            })
                .map(function (_operationData) { return "errors,\ndata"; })
                .join(",\n");
        var clientSideCalls = clientSideInvocations(operationDataList, options.postHttpMethod === true ? "post" : "get", options.useClientAuth);
        var whitespace = 4;
        var snippet = ts(netlifyGraphConfig, 'import type { NextApiRequest, NextApiResponse } from "next";') + "\n" + imp(netlifyGraphConfig, "NetlifyGraph", netlifyGraphConfig.netlifyGraphRequirePath) + ";\n\n" + exp(netlifyGraphConfig, "handler") + " = async (req" + ts(netlifyGraphConfig, ": NextApiRequest") + ", res" + ts(netlifyGraphConfig, ": NextApiResponse") + ") => {\n  // By default, all API calls use no authentication\n  let accessToken = null;\n\n  //// If you want to use the client's accessToken when making API calls on the user's behalf:\n  // accessToken = req.headers[\"authorization\"]?.split(\" \")[1];\n\n  //// If you want to use the API with your own access token:\n  // accessToken = process.env.ONEGRAPH_AUTHLIFY_TOKEN;\n      \n  const eventBodyJson = req.body || {};\n\n  " + fetcherInvocation + "\n\n  res.setHeader(\"Content-Type\", \"application/json\");\n\n  return res.status(200).json({\n" + addLeftWhitespace(passThroughResults, whitespace) + "\n  });\n};\n\n" + expDefault(netlifyGraphConfig, "handler") + ";\n\n/** \n * Client-side invocations:\n * Call your Netlify function from the browser with this helper:\n */\n\n/**\n" + clientSideCalls + "\n*/";
        var page = generatePage({
            operationData: firstOperation,
            schema: opts.schema,
            route: "/api/" + firstOperation.displayName,
        });
        var api = {
            kind: "UnnamedExportedFile",
            content: collapseExtraNewlines(snippet),
        };
        return {
            language: "javascript",
            exportedFiles: [api, page],
        };
    },
};
//# sourceMappingURL=nextjsExporter.js.map