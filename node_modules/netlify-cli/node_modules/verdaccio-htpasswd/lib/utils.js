"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addUserToHTPasswd = addUserToHTPasswd;
exports.changePasswordToHTPasswd = changePasswordToHTPasswd;
exports.getCryptoPassword = getCryptoPassword;
exports.lockAndRead = lockAndRead;
exports.parseHTPasswd = parseHTPasswd;
exports.sanityCheck = sanityCheck;
exports.verifyPassword = verifyPassword;

var _crypto = _interopRequireDefault(require("crypto"));

var _apacheMd = _interopRequireDefault(require("apache-md5"));

var _bcryptjs = _interopRequireDefault(require("bcryptjs"));

var _httpErrors = _interopRequireDefault(require("http-errors"));

var _fileLocking = require("@verdaccio/file-locking");

var _crypt = _interopRequireDefault(require("./crypt3"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// this function neither unlocks file nor closes it
// it'll have to be done manually later
function lockAndRead(name, cb) {
  (0, _fileLocking.readFile)(name, {
    lock: true
  }, (err, res) => {
    if (err) {
      return cb(err);
    }

    return cb(null, res);
  });
}
/**
 * parseHTPasswd - convert htpasswd lines to object.
 * @param {string} input
 * @returns {object}
 */


function parseHTPasswd(input) {
  return input.split('\n').reduce((result, line) => {
    const args = line.split(':', 3);

    if (args.length > 1) {
      result[args[0]] = args[1];
    }

    return result;
  }, {});
}
/**
 * verifyPassword - matches password and it's hash.
 * @param {string} passwd
 * @param {string} hash
 * @returns {boolean}
 */


function verifyPassword(passwd, hash) {
  if (hash.match(/^\$2(a|b|y)\$/)) {
    return _bcryptjs.default.compareSync(passwd, hash);
  } else if (hash.indexOf('{PLAIN}') === 0) {
    return passwd === hash.substr(7);
  } else if (hash.indexOf('{SHA}') === 0) {
    return _crypto.default.createHash('sha1') // https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding
    .update(passwd, 'utf8').digest('base64') === hash.substr(5);
  } // for backwards compatibility, first check md5 then check crypt3


  return (0, _apacheMd.default)(passwd, hash) === hash || (0, _crypt.default)(passwd, hash) === hash;
}
/**
 * addUserToHTPasswd - Generate a htpasswd format for .htpasswd
 * @param {string} body
 * @param {string} user
 * @param {string} passwd
 * @returns {string}
 */


function addUserToHTPasswd(body, user, passwd) {
  if (user !== encodeURIComponent(user)) {
    const err = (0, _httpErrors.default)('username should not contain non-uri-safe characters');
    err.status = 409;
    throw err;
  }

  if (_crypt.default) {
    passwd = (0, _crypt.default)(passwd);
  } else {
    passwd = '{SHA}' + _crypto.default.createHash('sha1').update(passwd, 'utf8').digest('base64');
  }

  const comment = 'autocreated ' + new Date().toJSON();
  let newline = `${user}:${passwd}:${comment}\n`;

  if (body.length && body[body.length - 1] !== '\n') {
    newline = '\n' + newline;
  }

  return body + newline;
}
/**
 * Sanity check for a user
 * @param {string} user
 * @param {object} users
 * @param {number} maxUsers
 * @returns {object}
 */


function sanityCheck(user, password, verifyFn, users, maxUsers) {
  let err; // check for user or password

  if (!user || !password) {
    err = Error('username and password is required');
    err.status = 400;
    return err;
  }

  const hash = users[user];

  if (maxUsers < 0) {
    err = Error('user registration disabled');
    err.status = 409;
    return err;
  }

  if (hash) {
    const auth = verifyFn(password, users[user]);

    if (auth) {
      err = Error('username is already registered');
      err.status = 409;
      return err;
    }

    err = Error('unauthorized access');
    err.status = 401;
    return err;
  } else if (Object.keys(users).length >= maxUsers) {
    err = Error('maximum amount of users reached');
    err.status = 403;
    return err;
  }

  return null;
}

function getCryptoPassword(password) {
  return `{SHA}${_crypto.default.createHash('sha1').update(password, 'utf8').digest('base64')}`;
}
/**
 * changePasswordToHTPasswd - change password for existing user
 * @param {string} body
 * @param {string} user
 * @param {string} passwd
 * @param {string} newPasswd
 * @returns {string}
 */


function changePasswordToHTPasswd(body, user, passwd, newPasswd) {
  let lines = body.split('\n');
  lines = lines.map(line => {
    const [username, password] = line.split(':', 3);

    if (username === user) {
      let _passwd;

      let _newPasswd;

      if (_crypt.default) {
        _passwd = (0, _crypt.default)(passwd, password);
        _newPasswd = (0, _crypt.default)(newPasswd);
      } else {
        _passwd = getCryptoPassword(passwd);
        _newPasswd = getCryptoPassword(newPasswd);
      }

      if (password == _passwd) {
        // replace old password hash with new password hash
        line = line.replace(_passwd, _newPasswd);
      } else {
        throw new Error('Invalid old Password');
      }
    }

    return line;
  });
  return lines.join('\n');
}
//# sourceMappingURL=utils.js.map